<?xml version="1.0" encoding="utf-8"?>
<items>
<item><url>https://www.cnblogs.com/holmze/</url><title>氧化氟碳 - 博客园</title><text></text><lastUpdated>None</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/default.html?page=2</url><title>随笔列表第2页 - 氧化氟碳 - 博客园</title><text></text><lastUpdated>None</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/p/13797920.html</url><title>2020软工第四次作业（结对编程第二次作业） - 氧化氟碳 - 博客园</title><text><value>
    </value><value>第二次结对作业</value><value>
</value><value>1.Information</value><value>
</value><value>
</value><value>
</value><value>
</value><value>这个作业属于哪个课程</value><value>
</value><value>软件工程2020秋</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>这个作业要求在哪里</value><value>
</value><value>第四次作业（结对编程第二次作业）</value><value>
</value><value>
</value><value>
</value><value>这个作业的目标</value><value>
</value><value>锻炼协作能力，实现部分功能</value><value>
</value><value>
</value><value>
</value><value>学号</value><value>
</value><value>031804103</value><value> 、 </value><value>051806129</value><value>
</value><value>
</value><value>
</value><value>GitHub address</value><value>
</value><value>031804103&amp;051806129</value><value>
</value><value>
</value><value>
</value><value>
</value><value>2.分工</value><value>
</value><value>
</value><value>陈翰泽：代码review、测试、撰写博客、GitHub管理与维护</value><value>
</value><value>谢润锋：设计、编码实现</value><value>
</value><value>
</value><value>3.PSP</value><value>
</value><value>
</value><value>
</value><value>
</value><value>PSP</value><value>
</value><value>Pair programming Process Stages</value><value>
</value><value>预估耗时（分钟）</value><value>
</value><value>实际耗时（分钟）</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>Planning</value><value>
</value><value>计划</value><value>
</value><value>15</value><value>
</value><value>15</value><value>
</value><value>
</value><value>
</value><value>Estimate</value><value>
</value><value>估计这个任务需要多少时间</value><value>
</value><value>10</value><value>
</value><value>10</value><value>
</value><value>
</value><value>
</value><value>Development</value><value>
</value><value>开发</value><value>
</value><value>300</value><value>
</value><value>270</value><value>
</value><value>
</value><value>
</value><value>Analysis</value><value>
</value><value>需求分析 (包括学习新技术)</value><value>
</value><value>30</value><value>
</value><value>25</value><value>
</value><value>
</value><value>
</value><value>Design Spec</value><value>
</value><value>生成设计文档</value><value>
</value><value>30</value><value>
</value><value>45</value><value>
</value><value>
</value><value>
</value><value>Design Review</value><value>
</value><value>设计复审</value><value>
</value><value>20</value><value>
</value><value>25</value><value>
</value><value>
</value><value>
</value><value>Coding Standard</value><value>
</value><value>代码规范 (为目前的开发制定合适的规范)</value><value>
</value><value>10</value><value>
</value><value>10</value><value>
</value><value>
</value><value>
</value><value>Design</value><value>
</value><value>具体设计</value><value>
</value><value>120</value><value>
</value><value>150</value><value>
</value><value>
</value><value>
</value><value>Coding</value><value>
</value><value>具体编码</value><value>
</value><value>180</value><value>
</value><value>240</value><value>
</value><value>
</value><value>
</value><value>Code Review</value><value>
</value><value>代码复审</value><value>
</value><value>45</value><value>
</value><value>45</value><value>
</value><value>
</value><value>
</value><value>Test</value><value>
</value><value>测试（自我测试，修改代码，提交修改）</value><value>
</value><value>30</value><value>
</value><value>45</value><value>
</value><value>
</value><value>
</value><value>Reporting</value><value>
</value><value>报告</value><value>
</value><value>0</value><value>
</value><value>0</value><value>
</value><value>
</value><value>
</value><value>Test Report</value><value>
</value><value>测试报告</value><value>
</value><value>30</value><value>
</value><value>30</value><value>
</value><value>
</value><value>
</value><value>Size Measurement</value><value>
</value><value>计算工作量</value><value>
</value><value>20</value><value>
</value><value>20</value><value>
</value><value>
</value><value>
</value><value>Postmortem &amp; Process Improvement Plan</value><value>
</value><value>事后总结, 并提出过程改进计划</value><value>
</value><value>20</value><value>
</value><value>20</value><value>
</value><value>
</value><value>
</value><value>合计</value><value>
</value><value>
</value><value>860</value><value>
</value><value>940</value><value>
</value><value>
</value><value>
</value><value>
</value><value>4.解题思路与设计实现</value><value>
</value><value>4.1 实现思路</value><value>
</value><value>使用HTML+JavaScript+CSS创建一个网页，在文本框接收特定格式的输入信息（具体的输入格式见</value><value>GitHub README</value><value>或 6.2部分），在后台解析数据为json格式，提取关键词后形成节点，从根节点开始建立学术家族树。</value><value>
</value><value>4.2 流程图</value><value>
</value><value>
</value><value>4.3 关键部分实现</value><value>
</value><value>4.3.1 调用d3框架</value><value>
</value><value>我们使用了d3框架，</value><value>使用的时候需要联网</value><value>。</value><value>
</value><value>&lt;head&gt;&lt;script type="text/javascript" src="http://d3js.org/d3.v3.min.js"&gt;&lt;/script&gt;&lt;/head&gt;
</value><value>
</value><value>4.3.2 接收数据</value><value>
</value><value>文本域textarea用于接收输入数据。</value><value>
</value><value>&lt;p style="text-align:center"&gt;
    &lt;textarea cols="60" rows="10" id="text"&gt;&lt;/textarea&gt;
&lt;/p&gt;
</value><value>
</value><value>4.3.3 解析数据</value><value>
</value><value>我们在输入格式中规定，将输入分为：</value><value>人际关系树</value><value>、</value><value>个人技能</value><value>、</value><value>职场经历</value><value>三部分，</value><value>每部分之间以空行分隔，且只能有一个空行</value><value>，</value><value>输入结束至少有一个空行</value><value>，所以我们按照空行分割输入数据，然后按照关键字提取节点以及节点信息和关系。</value><value>
</value><value>var content = document.all.text.value;
var edge = new Map;
var keyword = ["导师：","级硕士生：","级本科生：","级博士生："];
var seen_s_w = new Map;
var farther_flag = new Map;
var seen = [];
split_idx = [];
var farther = new Map;

// input data process
arr_str = content.split("\n");
var idx1;
var idx2;
var idx3;

for (var idx = 0 ; idx &lt; arr_str.length ; idx ++ )
{
    if (arr_str[idx] == "")
    {
        split_idx.push(idx);
    }
}

// get teacher and student relation
for (idx1 = 0 ; idx1 &lt; split_idx[0] ; ) // layer 1
{
    idx2 = split_idx[0];
    // get teacher
    var layer1_term = arr_str[idx1].split("：");
    var tutor_name = layer1_term[1];
    edge[tutor_name] = [];
    seen.push(tutor_name);
    for (idx3 = idx1 + 1 ; idx3 &lt; idx2 ; idx3 ++)
    {
        var layer1_item = arr_str[idx3].split("：");
        var layer1_node = layer1_item[0] + tutor_name;
        farther[layer1_item[0]] = tutor_name;
        edge[tutor_name].push(layer1_node);
        edge[layer1_node] = [];
        farther_flag[layer1_node] = 1;
        seen.push(layer1_node);
        var student = layer1_item[1].split("、");
        for (var stu of student)
        {
            farther[stu] = layer1_node;
            stu = stu + layer1_node;
            farther[stu] = layer1_node;
            edge[layer1_node].push(stu);
            farther_flag[stu] = 1;
            seen.push(stu);
        }
    }
    idx1 = idx2 + 1;
}
//console.log(farther);
if (split_idx.length &gt;= 2)
{
    for (idx3 = idx1 ; idx3 &lt; split_idx[1] ; idx3 ++)
    {
        var layer2_item = arr_str[idx3].split("：");
        var current_f = farther[layer2_item[0]];
        var layer2_node = layer2_item[0] + current_f;
        edge[layer2_node] = [];
        farther_flag[layer2_node] = 1;
        seen.push(layer2_node);
        var skill_or_work = layer2_item[1].split("、");
        for (var sw of skill_or_work)
        {
            edge[layer2_node].push(sw);
            farther_flag[sw] = 1;
            seen.push(sw);
            seen_s_w[sw] = 1;
        }
    }
}
//		console.log(edge);
if (split_idx.length == 3)
{
    for (idx3 = split_idx[1] + 1 ; idx3 &lt; split_idx[2] ; idx3 ++)
    {
        var layer3_item = arr_str[idx3].split("：");
        var current_f = farther[layer3_item[0]];
        var layer3_node = layer3_item[0] + current_f;
        edge[layer3_node] = [];
        farther_flag[layer3_node] = 1;
        seen.push(layer3_node);
        var work = layer3_item[1].split("、");
        for (var w of work)
        {
            edge[layer3_node].push(w);
            farther_flag[w] = 1;
            seen.push(w);
            seen_s_w[w] = 1;
        }
    }
}
// find root node
for (var val of seen)
{
    if (farther_flag[val] == null)
    {
        var root_name = val;
    }
}
//console.log(root_name);
</value><value>
</value><value>4.3.4 DFS算法</value><value>
</value><value>我们在处理完输入数据后，使用DFS（Depth First Search）算法按照输入格式代表的节点关系构建json树。</value><value>
</value><value>function dfs(n,f) // construct object
{
    console.log(n,f);
    var obj;
    obj = {};
    obj.name = n;
    obj.children = [];
    var item_list = edge[n];
    if (item_list == null)
    {
        //console.log(n);
        if (seen_s_w.hasOwnProperty(n) == false)
        obj.name = n.substring(0,n.indexOf(f));
        return obj;
    }
    for (var i = 0 ; i &lt; item_list.length ; i ++)
    {
        obj.children.push(dfs(item_list[i],n));
    }
    if (n.indexOf(f) != -1) // no farther
    {
        var c = n.substring(0,n.indexOf(f));
        obj.name = c;
    }
    return obj;
}
</value><value>
</value><value>5.附加特点设计与展示</value><value>
</value><value>5.1 学术家族树的缩放与拖动功能</value><value>
</value><value>// Transition nodes to their new position.节点过渡过程中的过渡效果
//为图形添加过渡动画
var nodeUpdate = node.transition()  //开始一个动画过渡
    .duration(duration)  //过渡延迟时间,此处主要设置的是圆圈节点随斜线的过渡延迟
    .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });//YES
// Transition exiting nodes to the parent's new position.过渡现有的节点到父母的新位置。
//最后处理消失的数据，添加消失动画
var nodeExit = node.exit().transition()
    .duration(duration)
    .attr("transform", function(d) { return "translate(" + source.x + "," + source.y + ")"; })//YES
    .remove();

// Update the links…线操作相关
//再处理连线集合
var link = svg.selectAll("path.link")
    .data(links, function(d) { return d.target.id; });
// Enter any new links at the parent's previous position.
//添加新的连线
link.enter().insert("path", "g")
    .attr("class", "link")
    .attr("d", function(d) {
        var o = {y: source.x0, x: source.y0};//YES
        return diagonal({source: o, target: o});  //diagonal - 生成一个二维贝塞尔连接器, 用于节点连接图.
    })
    .attr('marker-end', 'url(#arrow)');
// Transition links to their new position.将斜线过渡到新的位置
//保留的连线添加过渡动画
link.transition()
    .duration(duration)
    .attr("d", diagonal);
// Transition exiting nodes to the parent's new position.过渡现有的斜线到父母的新位置。
//消失的连线添加过渡动画
link.exit().transition()
    .duration(duration)
    .attr("d", function(d) {
        var o = {x: source.x, y: source.y};//NO
        return diagonal({source: o, target: o});
    })
    .remove();
// Stash the old positions for transition.将旧的斜线过渡效果隐藏
nodes.forEach(function(d) {
    d.x0 = d.y;
    d.y0 = d.x;
});
}
</value><value>
</value><value>5.2 学术家族树节点的折叠功能</value><value>
</value><value>//定义一个将某节点折叠的函数
// Toggle children on click.切换子节点事件
function click(d) {
if (d.children) {
    d._children = d.children;
    d.children = null;
} else {
    d.children = d._children;
    d._children = null;
}
update(d);
}
</value><value>
</value><value>6.目录说明和使用说明</value><value>
</value><value>6.1 目录说明</value><value>
</value><value>
</value><value>
</value><value>title部分保存页面标题，即显示在浏览器标签上的标题</value><value>
</value><value>style保存页面设计设计风格信息</value><value>
</value><value>在head部分调用d3框架</value><value>
</value><value>在body构建页面的具体部件以及部件信息
</value><value>
</value><value>body.spript中放置JavaScript代码作为后台运行代码</value><value>
</value><value>
</value><value>
</value><value>
</value><value>6.2 使用说明</value><value>
</value><value>step1</value><value>
</value><value>首先使用chrome浏览器打开web.html文件</value><value>
</value><value>
</value><value>step2</value><value>
</value><value>按照输入格式在文本框输入文本，输入部分主要是：</value><value>
</value><value>
</value><value>师生关系</value><value>
</value><value>技能</value><value>
</value><value>工作</value><value>
</value><value>
</value><value>每个部分之间需用一个换行符分开，如果输入结束就在末尾加一个回车加以表示。支持的数据输入组合为：师生关系，师生关系+技能，师生关系+工作，师生关系+技能+工作，</value><value>
例如：</value><value>
</value><value>导师：张三
2016级博士生：天一、王二、吴五
2015级硕士生：李四、王五、许六
2016级硕士生：刘一、李二、李三
2017级本科生：刘六、琪七、司四

刘六：JAVA、数学建模
李四：PYTHON、VUE

李二：字节跳动、京东云
刘一：阿里

</value><value>
</value><value>输入完毕后点击下方的</value><value>提交</value><value>键。</value><value>
</value><value>
</value><value>step3</value><value>
</value><value>在</value><value>提交</value><value>键下方出现学术家族树，并支持用鼠标的滚轮缩放以及鼠标拖动家族树，点击节点可以折叠此节点的所有子节点。</value><value>
</value><value>
</value><value>7.mocha测试</value><value>
</value><value>使用macha测试框架，使用教程--&gt;</value><value>测试框架Mocha实例教程-阮一峰</value><value>
首先下载安装node.js </value><value>in here</value><value>，然后通过NPM安装mocha库和chai：</value><value>
</value><value>npm install --g mocha
npm install --g chai
</value><value>
</value><value>接下来编写测试程序，测试将输入文本处理为json文件的函数，编写五个样例进行测试。</value><value>
</value><value>var get_json = require('./web.js').get_json;
var expect = require('chai').expect;
var str=`导师：张三
2016级博士生：天一、王二、吴五
2015级硕士生：李四、王五、许六
2016级硕士生：刘一、李二、李三
2017级本科生：刘六、琪七、司四

刘六：JAVA、数学建模

李二：字节跳动、京东云
`;
var ans='{"name":"张三","children":[{"name":"2016级博士生","children":[{"name":"天一","children":[]},{"name":"王二","children":[]},{"name":"吴五","children":[]}]},{"name":"2015级硕士生","children":[{"name":"李四","children":[]},{"name":"王五","children":[]},{"name":"许六","children":[]}]},{"name":"2016级硕士生","children":[{"name":"刘一","children":[]},{"name":"李二","children":[{"name":"字节跳动","children":[]},{"name":"京东云","children":[]}]},{"name":"李三","children":[]}]},{"name":"2017级本科生","children":[{"name":"刘六","children":[{"name":"JAVA","children":[]},{"name":"数学建模","children":[]}]},{"name":"琪七","children":[]},{"name":"司四","children":[]}]}]}';
describe('测试数据处理函数', function() {
    it('生成的字符串应该等于ans', function() {
    expect(get_json(str)).to.be.equal(ans);
    });
});
</value><value>
</value><value>
</value><value>此处同时测试五个样例，更多mocha测试样例以及测试说明请看===&gt;</value><value>README.md</value><value>
</value><value>8.GitHub记录</value><value>
</value><value>
</value><value>
</value><value>
</value><value>9.遇到的代码模块异常或结对困难及解决方法</value><value>
</value><value>1 对输入数据的处理（一开始不能处理多行数据）</value><value>
</value><value>原因：因为变量名和循环层数太多，所以在处理过程中搞混了变量名。（如前几版代码）因为目的是找出当前节点的父亲节点，所以解决方法是通过哈希表，省去了一顿变量和好多层循环，代码简洁许多。</value><value>
</value><value>2 Json对象的建立（dfs过程中遇到的问题）</value><value>
</value><value>一开始最后一层无法搜索到，发现原因是父亲节点没有存储好。解决方法依旧通过hash表存储父亲，然后直接访问，成功解决问题。建树过程主要是通过百度查找前辈们做过的精美树形结构然后进行综合起来参考。</value><value>
</value><value>10.评价你的队友</value><value>
</value><value>（商业互吹）</value><value>
</value><value>
</value><value>陈翰泽：谢大佬思路清晰，执行能力强，交流能力出色。
</value><value>
</value><value>队友值得学习的地方：清晰且宽广的思路，以及高效的执行编码能力。</value><value>
</value><value>队友需要改进的地方：变量名和函数名的设置有待提高，或者说是我跟不上大佬的思维吧。</value><value>
</value><value>
</value><value>
</value><value>谢润锋：翰泽巨佬写博客小能手，github6的一匹，沟通积极并且及时。
</value><value>
</value><value>队友值得学习的地方：他写博客的技巧很多表述也很清晰，并且有很高的GitHub的熟练度，需要我认真学习。</value><value>
</value><value>队友需要改进的地方：因为我们分工明确，并且出现问题能够及时互通，所以这次任务完成的较为顺利，没有较大的缺陷，只是阅读代码的能力有待提高。</value><value>
</value><value>
</value><value>
</value><value>

</value></text><lastUpdated>2020-10-11 22:19</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/archive/2019/02/24.html</url><title>2019 年 2月 24 日 随笔档案 - 氧化氟碳 - 博客园</title><text></text><lastUpdated>None</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/archive/2019/04/09.html</url><title>2019 年 4月 9 日 随笔档案 - 氧化氟碳 - 博客园</title><text></text><lastUpdated>None</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/p/13619620.html</url><title>2020软工第一次作业 - 氧化氟碳 - 博客园</title><text><value>
    </value><value>
</value><value>
</value><value>
</value><value>这个作业属于哪个课程</value><value>
</value><value>软件工程2020秋</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>这个作业要求在哪里</value><value>
</value><value>第一次作业</value><value>
</value><value>
</value><value>
</value><value>这个作业的目标</value><value>
</value><value>自我介绍，和老师助教同学互相了解；初步熟悉git和博客平台</value><value>
</value><value>
</value><value>
</value><value>学号</value><value>
</value><value>031804103</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>自我介绍</value><value>
</value><value>我叫chz，来自福建泉州。喜欢足球和古典音乐，尤其是</value><value>莫扎特</value><value>和</value><value>柴可夫斯基</value><value>，好读书不求甚解。去年徒步爬过一次华山，体验是此后半年都没有爬山的欲望，在山顶等日出的时候想起射雕五绝爬完华山还能打五天五夜，怪不得我成不了武林高手。</value><value>
</value><value>技能树和技术偏好</value><value>
</value><value>
</value><value>技能树：
</value><value>
</value><value>比较经常用Python和Java；</value><value>
</value><value>玩过Hadoop，所以也略懂一点Linux；</value><value>
</value><value>懂一些Latex写作；</value><value>
</value><value>跑过几个C++的DEMO；</value><value>
</value><value>爬虫和机器学习的技能正在修炼；</value><value>
</value><value>GitHub一些基本操作还算可以，高阶功能还不太熟悉；</value><value>
</value><value>用markdown写过一些文档/笔记，比如：</value><value>Holmze的数学建模笔记</value><value>
</value><value>
</value><value>
</value><value>技术偏好：emmmm没有什么强烈的偏好（主要是也都需要现学），条件允许的话希望是后端。</value><value>
</value><value>
</value><value>代码量</value><value>
</value><value>没有统计过，大概3~4k？希望这学期之后能翻倍。</value><value>
</value><value>希望获得什么&amp;希望担任的角色</value><value>
</value><value>
</value><value>希望的收获
</value><value>
</value><value>首先当然是coding能力啦；</value><value>
</value><value>丰富技能树，深度广度都可以；</value><value>
</value><value>团队协作的能力，尤其是和其他程序员的交互；</value><value>
</value><value>希望提高理解他人代码的能力；</value><value>
</value><value>
</value><value>
</value><value>希望的角色：希望能负责一个需要合作并且可以锻炼能力的任务；或者做个组织调度的角色，很喜欢哈维阿隆索那种风格。</value><value>
</value><value>缺少什么技能（虽然我觉得技能是一直缺乏的，怎么样都不够用）：
</value><value>
</value><value>写大型工程代码的能力</value><value>
</value><value>和他人交互交流的能力</value><value>
</value><value>快速阅读理解其他程序员代码的能力</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>截图：</value><value>
</value><value>cnblog markdown:</value><value>
</value><value>
</value><value>GitHub page:</value><value>
</value><value>

</value></text><lastUpdated>2020-09-05 20:48</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/p/10674489.html</url><title>Coursera:Internet History ,Techornology and Security - 氧化氟碳 - 博客园</title><text><value>
    </value><value>WEEK1</value><value>
</value><value>War Time Computing and Communication</value><value>
</value><value>
</value><value>Bletchley Park 布莱彻利庄园：a top-secret code breaking effort by the British government during World War II. 二战时期英国政府为了破译德国的“Enigma”电报加密装置而设立的，聚集了一大批高端的密码学、数学人才的基地。最后在Alan Truing(艾伦图灵)的主导下设计了第一个计算机。（以上中文注释来自笔者观看电影《模仿游戏》得到的资料）
</value><value>
</value><value>笔者的注释：严格意义上来说Alan Turing此时参与研制的计算机与现在常见的计算机有一些不同。在Bletchley Park诞生的计算机学术上称为电子模拟计算机，其数值是由一些例如指针转动、计算尺长度表示的（这点在本课程的视频Alan Turing and Bletchley Park中的计算机复制品的运作场景也可以得到印证，其运算的时候有很多个转盘同时在运动）。而现在常见的计算机被称作电子数字计算机，其数值是按位运算的，而且不断跳动。</value><value>
</value><value>
</value><value>
</value><value>Bomba：波兰人研制的破解Enigma的机器主要针对的是德国人repeating the message header(重复使用信息头)</value><value>
</value><value>Bombe：以Alan Turing为首的团队设计的机器，主要针对的是德国人sending stereotyped messages（模块化的信息，也就是有一定格式的军事指令）.</value><value>
</value><value>Colossus（巨人）：针对德国加密机器升级版的机器，第一台被称作Mark 1.(难道Iron Man命名的灵感就来源于此？)第二台称作Mark 2.Mark 2直接参与了诺曼底登陆战。巨人计算机具有大多数现代计算机的特征，除了没有内存。通过纸条读取数据，</value><value>
</value><value>
</value><value>Computing with Phone Lines</value><value>
</value><value>
</value><value>这部分主要介绍了早期计算机之间的联通模式：通过电话线拨号实现信息传送
</value><value>
</value><value>local call to local computer</value><value>
</value><value>distance call to remote computer（有点类似于远程计算机）</value><value>
</value><value>computer to computer（leased lines）：较昂贵，常见于银行系统</value><value>
</value><value>
</value><value>
</value><value>
</value><value>WEEK2</value><value>
</value><value>Supercomputers Justify a National Network</value><value>
</value><value>
</value><value>这部分主要介绍了早期计算机之间的连接方式及其演变。
</value><value>
</value><value>1.电缆连接（有线连接、专线网络）leased lines
</value><value>
</value><value>通过电缆直接将计算机联系在一起。It is really expensive.The cost base on distance.成本与距离线性相关。</value><value>
</value><value>传输速度慢</value><value>
</value><value>信息需要排队通过</value><value>
</value><value>Save Money with More "Hops"：通过连接更多的学校（因为当时只有学校拥有计算机），来分摊修建路电缆的费用已达到减少开支的方法。</value><value>
</value><value>
</value><value>
</value><value>2.Bitnet比特网，校园网的主要方式
</value><value>
</value><value>为了节省开支而产生的连接方式</value><value>
</value><value>缺点和优点一样明显：大号的文件可能会长时间占用线路，影响其他较小文件的传输，所以传输速度很慢。</value><value>
</value><value>
</value><value>
</value><value>3.ARPANET：美国军方研制的，供给军队使用的网络
</value><value>
</value><value>the primary motivation was to improve the use of their compution equipment.</value><value>
</value><value>ARPANET与Bitnet的主要区别：“packet switching”（分组交换）：sending data across the link and then keep sending it until it was done.
</value><value>
</value><value>packet:breakinga big message into small parts,labeling each one of them individually将数据分块成为数据包，以数据包为单位传输数据</value><value>
</value><value>able to sneak and bypass the traffic jam能够避开交通堵塞（这里的traffic jam可以理解为处在busy的线路）</value><value>
</value><value>allowing simultaneously multible message to be in fight at the same time（个人将这句话理解为允许同是传送不同消息，这里体现了ARPANET与Bitnet的重要不同）</value><value>
</value><value>同一组数据在被分成数据包以后可能会经由不同路径进行传输，但是因为路径的不同数据包可能在不同时间送达。就好比我在淘宝上买东西了一个手办（message），但是店家把这个手办的分解成零件（packets），从北京中关村发到福州上街镇，但是可能每个零件从北京到福州的路径不一样例如有一个零件走的是（北京--&gt;济南--&gt;南京--&gt;杭州--&gt;福州），而另一个零件走的是（北京--&gt;太原--&gt;西安--&gt;重庆--&gt;贵阳--&gt;南宁--&gt;广州--&gt;福州），但无论通过什么路径，最后都能到福州，而我需要做的是按照说明书把手办拼起来。</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>between getway and getway have links and routers（路由器，主要作用是转发信息）:breaking messages into packets,packets can take different paths,and then they arrive and they are reassembled(重组)</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>Larry Smarr
</value><value>
</value><value>天文物理学家，因为接触到了一个需要超级超级计算能力的课题，于是不遗余力的推动超级计算机的建设。经过不断的努力，后来还建立了NSFNET</value><value>
</value><value>
</value><value>
</value><value>
</value><value>The frist "Internet"</value><value>
</value><value>
</value><value>这部分主要讲述了一些Internet发展过程中的曲折故事和相关访谈。</value><value>
</value><value>Doug Van Houweiling
</value><value>
</value><value>因为各方面原因大学难以拥有自己的超级计算机，于是另辟蹊径为密歇根大学的计算机建立了网络。最早的预算只够建立运输速度为56kb的线路，后来在一系列的争取以后，将其提高到了1.5mb。自此，NSFNet成为世界上最快的网络，取代ARPANET成为世界主流网络。</value><value>
</value><value>
</value><value>
</value><value>Leonard Kilenrock</value><value>
</value><value>Katie Hafner（一个记者，曾经准备写关于互联网的专题报道）</value><value>
</value><value>NSFNet:National Science Foundation,美国国家科学基金会,简称NSF</value><value>
</value><value>
</value><value>WEEK3</value><value>
</value><value>The Early World-Wide-Web</value><value>
</value><value>
</value><value>这部分描述了早期的world-wide-web（万维网）</value><value>
</value><value>Robert Cailliau :one of the co-inventor of the world-wide-web
</value><value>
</value><value>Physcists have need for spreeding documentation around .So they built something like centralized databases((集中式数据库) to kept high energy physics articles(高能量物理学文章).</value><value>
</value><value>Robert将计算机分割为上层（browser浏览器)和下层（database数据库）</value><value>
</value><value>The first server was up end of 1990 in the USA.</value><value>
</value><value>Gopher：早期的信息检索工具，在WWW出现以前是主要的信息检索工具。</value><value>
</value><value>Mosaic:Firefox浏览器前身，历史上著名的浏览器，运行时只有一个窗口，每个新窗口自动代替上一个界面。</value><value>
</value><value>WWW的特点：every time that you clicked here, you had another window（与Mosaic的重要区别：每次点击都会打开一个新的页面）</value><value>
</value><value>1994年，第一届国际万维网大会召开，</value><value>
</value><value>
</value><value>
</value><value>
</value><value>A Search Engine for Physics Articles</value><value>
</value><value>
</value><value>这部分介绍了物理学文章的搜索引擎</value><value>
</value><value>use the database by the web.（此处的database就是前文中提到的存放物理学文章的centralized databases）</value><value>
</value><value>The first Web server in America can query a database on a mainframe.（美国第一台网络服务器可以在数据库中查询数据）</value><value>
</value><value>Paul kunz used a CREN server software ,which was written in C to creates the first Web server in America.
</value><value>
</value><value>get the query that the user had made and turn it into a database query.（获取用户所做的查询并将其转换为数据库查询）</value><value>
</value><value>
</value><value>
</value><value>
</value><value>Making the Web Available to All</value><value>
</value><value>
</value><value>Gopher：在web流行起来以前gopher是主流的网络资源检索工具</value><value>
</value><value>Mosaic：另一款浏览器，由NCSA的Joseph Hardin牵头发明
</value><value>
</value><value>At 1990s,NCSA at Urbana-Champaign, University of Illinois, built an open source web browser that worked on Mac, Windows, and Unix. （支持多个多个系统）</value><value>
</value><value>it is possible for people to share in real time images of their data, the spreadsheets of their data, and papers.</value><value>
</value><value>有必要提一下的是，后来Mosaic项目的大部分员工创建了有名的网景公司（Netscape），该公司推出了现在很多人使用的Firefox浏览器。</value><value>
</value><value>
</value><value>
</value><value>
</value><value>WEEK4</value><value>
</value><value>Explosive Growth of the Internet and Web</value><value>
</value><value>
</value><value>1994:Year of the Web（1994年时互联网发展的重要一年，互联网不再是纯粹的学术或者技术，而是带来了许多的资金投入，许多的it公司的建立等等）</value><value>
在当时许多的公司之中，Netscape与Microsoft无疑是强烈的竞争对手，但是当时的Netscape的体量和Microsoft相比还比较小，Netscape险些被Microsoft收购吞并。</value><value>
</value><value>Mitchell Baker: one of the founders of Mozilla.
</value><value>
</value><value>Microsoft收购Netscape失败以后二者进入了竞争。</value><value>
</value><value>Netscape is a failure product，because of it ，Baker was be laying off in 2001. But it wasn't really possible to take her place and she continued as a volunteer.</value><value>
</value><value>在这段竞争岁月中，网景公司创造了现在依然很火的JavaScript语言。后来两家之间以价格为主要战场的商业战争不再赘述，毕竟我不需要分析这次市场竞争行为的利弊以及历史意义。（套路无非是恶性降价竞争，甚至免费的产品，以达到占领市场的目的。但是这个时候的发展重点依然是技术，而不是一味的打价格战。如果当时有融资这种东西的话，就和和这几年的某些公司在某些领域的竞争很像了）</value><value>
</value><value>In 2003 the Mozilla foundation was formed</value><value>
</value><value>
</value><value>
</value><value>Brendan Eich:JavaScript主要创造者与架构师
</value><value>
</value><value>JavaScript和Java的关系不大（我长期以来一直以为JavaScript时Java的延申或者在某一方面的定制版本，这次课纠正了我这个思维定势）</value><value>
</value><value>JavaScript是一种对初学者和业余程序员都比较友好的语言。</value><value>
</value><value>
</value><value>
</value><value>
</value><value>Commercialization of the Web</value><value>
</value><value>
</value><value>这部分主要讲述了网络商业化</value><value>
</value><value>Microsoft give their browser away free, which made it impossible for Netscape to charge for the browser.（微软为了竞争而对用户免费提供浏览器）</value><value>
</value><value>the World Wide Web Consortium（万维网联盟） was created in October of 1994.
</value><value>
</value><value>Jeff Bezos: the founder of Amazon.com(亚马逊创始人贝索斯，没错就是最近离婚的那个)
</value><value>
</value><value>books is the frist product to sell online.Music is the second.最早亚马逊买的是书，后来扩展到CD一类的音乐产品。</value><value>
</value><value>说到网购平台，突然想起来最近看到的一个关于马云的视频，感触颇深，视频来自虎扑步行街--&gt;</value><value>传送门</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>WEEK5</value><value>
</value><value>Link</value><value>
</value><value>
</value><value>Hops:one portion of the path between source and destination. Data packets pass through bridges(网桥), routers and gateways（网关） as they travel between source and destination. Each time packets are passed to the next network device, a hop occurs.[插入图片Hop-count-trans.png]</value><value>
</value><value>Packet-switching(分组交换)：break message into packets(将信息分割成数据包，)
</value><value>
</value><value>bridge,router,gateway is forwarding packets(网桥、路由器、网关负责的是储存与中转数据包)，but not longs term storage of message.</value><value>
</value><value>
</value><value>
</value><value>shared Network infratructure only focuses on packets,not reliability or anyting else.（共享网络只关注数据包而不是可靠性或其他）</value><value>
</value><value>layered network model(分层网络模型)：OSI model（Open System Interconnection model开发系统互连模型）：为了简化解决方案，以便解决问题、管理，就将网络划分为几个部分。在每层中只需要考虑本层的问题，不需要被其他层的问题影响。</value><value>
</value><value>Layered Architecture(分层架构)
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>Link:一段传输介质，例如光缆，数据通过一个link就是一个hop，路由器接受上一个link的数据并将收到的数据push到下一个link。就好比在淘宝上买东西了一个手办（message），但是店家把这个手办的分解成零件（packets），每个packets在来福州的路上会经过许多中转站（rounter），而每个中转站之间的要用各种交通工具运输（link），中转站之间的运输就是hop。</value><value>
</value><value>
</value><value>how to avoid the chaos when they're sharing?
</value><value>
</value><value>with a technique called, Carrier Sense Media Access with Collision Detection.</value><value>
</value><value>To aviod garbled messages,systems must observe "rules"(Protocols)</value><value>
</value><value>Ethernet rules are simple</value><value>
</value><value>
</value><value>
</value><value>common link technologies:Ethernet（以太网）,WiFi,Cable modem（电缆调制解调器）,DSL(数字用户线路[拨号上网])，Satellite（卫星）,Optical（光纤）</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>Internet Protocol(互联网协议)</value><value>
</value><value>
</value><value>IP drop data if it go bad.如果数据包出错或传输数据有故障，可以丢弃这个数据包，避免出现错误残破的数据包。the address is broken into two parts. There is the network number part which is the prefix(前缀), and then there is the computer number within network.As soon as the packets enter the network, it only looks at the prefix.网络只关心IP地址的前缀，就是只关心来自哪个网络。</value><value>
</value><value>portable cpmputer:dynamic host configuration protocol：动态主机配置协议，主要用于解决移动计算机例如笔记本电脑、iPad等无固定本地连接的IP地址分配问题。即分配临时的本地IP，一般格式为192.168.xxx.xxx，而这个IP地址只属于本地网络，可以理解为IP地址的分支。这个方法也可以用来解决IP地址数量不足的问题。</value><value>
</value><value>network address translation（在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址）</value><value>
</value><value>Time-to-live (TTL) is a value in an Internet Protocol (IP) packet that tells a network router whether or not the packet has been in the network too long and should be discarded.告诉路由器数据包是否在网络中存在太久。当数据包的hops数超过255（32bit）是被丢弃。原理是如果一个数据包经过了255hops都还没送达，可以认为数据进入了死循环。为了避免占用网络引起网络拥堵，故产生了这种诊断方式。</value><value>
</value><value>
</value><value>WEEK6</value><value>
</value><value>Transport/Reliability</value><value>
</value><value>
</value><value>TCP层建立在IP层之上，TCP层的作用是弥补IP层可能出现的一些问题。</value><value>
</value><value>TCP（Transmission Control Protocol 传输控制协议）layer:The purpose of the TCP layer is to compensate for the possible errors in the IP layer as well as make best use of available resources.</value><value>
</value><value>the key idea in TCP/IP is that when we send some data, we break it into packets and then we send each one. And then we keep them until they get an acknowledgement（确认送达的回复） from the other side and then and only then do we throw them away. And at some point, if a packet gets lost It can be sent again, until it finally is acknowledged in the destination system.(预防传输过程出错而设置的机制，直到发送方确认发送完成才结束传输，若出现传输错误就重新发送，直到完全成功传输为止)It figures out which packets have or have not made it across the Internet layer.</value><value>
</value><value>作为一个球迷，笔者将TCP理解为莫德里奇（IP）身边的卡塞米罗（TCP），帮助IP防守的同时和IP协作使得球队（network）的运转更加流畅和顺利。（这是笔者的自嗨，换成加图索和皮尔洛或者类似的谁和谁一样成立，看不懂请忽略 ^</value><value>_</value><value>^ ）</value><value>
</value><value>the slow start algorithm at a high level。
</value><value>
</value><value>
</value><value>随着越来越多的计算机接入网络，网速变得很慢，许多数据包丢失。（是不是因为太长时间没有送达，上一周讲到的Time-to-live机制起作用了？）Van Jacobson对此的对策是：TCP congestion control.</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>这个机制简单描述就是，控制进入网络的packet数量（有点类似北京n环限号出行以缓解堵车的既视感），当收到确认送达的acknowledgement的时候才向网络发送packet。但是这个机制有一个难点就是起步的时候发送方不知道现在的网络状况如何（因为发送第一个数据包的时候没有上一个数据包的acknowledgement）。所以van Jacobson设计了Slow Start Algorithm（慢启动算法），也就是在数据传输的初期以慢速发送。这样就能够防止网络堵塞。</value><value>
</value><value>
</value><value>补充：不是只有收到上一个数据包的acknowledgement才发送下一个数据包（这样未免太慢了，顾此失彼），而是在发送开始的时候压低速度，后面在不影响网络速度的前提下逐步提高传输速度。</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>Domain Name System(域名系统)：the visible name that we could switch the mapping from the name of the IP address transparently(可以从IP地址名称切换映射的可见名称),a big distributed data base(分布式数据系统).[使用更加便于人类记忆的命名方式代替IP地址，IP地址是从左往右就是从大到小，而域名系统相反，例如www.si.umich.edu这个域名，edu代表这个域名属于教育机构，umich代表了教育机构里面的密歇根大学，si代表的是密歇根大学的信息学院，www是服务器]</value><value>
</value><value>the transport control protocol has a responsibility of compensating for the imperfections of the IP layer</value><value>
</value><value>
</value><value>WEEK7</value><value>
</value><value>Application</value><value>
</value><value>
</value><value>
</value><value>client application(客户端应用程序)</value><value>
</value><value>
</value><value>
</value><value>server application（服务器应用程序）</value><value>
</value><value>
</value><value>
</value><value>client app make request ,and server make response back.客户端发送请求，服务器返回响应内容。</value><value>
</value><value>
</value><value>
</value><value>two basic problem</value><value>
</value><value>
</value><value>which application gets the data:
</value><value>
</value><value>this is using a mechanism(机制) called ports(端口).ports allow a IP address or a single computer or a single server.端口依附于IP存在，类似于IP地址的分支路径。不同的端口对应不同的功能与服务。</value><value>
</value><value>下图是我的电脑的部分端口信息</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>application protocols(应用程序协议),在端口进行信息交换的规则。</value><value>
</value><value>
</value><value>
</value><value>过程：click--&gt;request--&gt;response--&gt;display</value><value>
</value><value>
</value><value>
</value><value>browers(浏览器)：request the server application ,HTML comes back ,which discribe how this page document supposed to show.And show to user.</value><value>
</value><value>
</value><value>
</value><value>HTTP：超文本传输协议，一种广泛使用的网络协议，一些网站前面加了“ http:// ”的意思就是该网站遵循HTTP协议</value><value>
</value><value>
</value><value>
</value><value>If we know how to talk, if we know what port to talk to, and we know what protocol to talk to that port we can write a client that meets the needs of that server and extract the data.(如果我们知道如何通信，如果我们知道要与哪个端口通信，如果我们知道要与那个端口通信的协议，我们就可以编写一个满足服务器需求的客户机并提取数据。)</value><value>
</value><value>
</value><value>
</value><value>Information that's sort of qualitatively the same as all naming or identity information, but it's spread randomly across the whole packet. (信息在质量上与所有命名或身份信息相同，但它在整个数据包中随机传播)</value><value>
</value><value>
</value><value>
</value><value>WEEK8</value><value>
</value><value>Hiding Data from Others</value><value>
</value><value>
</value><value>It is does not exist of absolute security.Security is a cost benefit analysis(成本效益分析)</value><value>
</value><value>security is naturally imperfect(安全是天生不完美的),世界上不存在绝对的安全，过度的安全会限制本身的各个活动，我们应该采用的是折衷方案。</value><value>
</value><value>confidentiality(保密性),encryption(加密) and decryption(解密)
</value><value>
</value><value>plain text and ciphertext(纯文本和密文)：Encryption is the act of going from plain text to ciphertext.And returning the ciphertext back to the plain text is decryption.</value><value>
</value><value>secret key
</value><value>
</value><value>symmetric key(对称密钥), which means that both parties have to be in possession of the same information,  basically use the same key material to encrypt as you do to decrypt.(双方必须拥有相同的信息,基本上使用与解密相同的密钥材料进行加密)</value><value>
</value><value>the problem that secret key has, that led to the need to invent a public key, is the fact that you need to at some point have a secure communication.(密钥机制的问题在于需要有一个完全安全的方式进行解密方式的传输)</value><value>
</value><value>shift(移位加密)：将文本的字母向上/向下移动n位(n=shift number,1 &lt; shift number &lt; 26)
</value><value>
</value><value>移位加密的破译方式很简单暴力，就是把1~25的shift number都使一次（很显然shift number为0或者26没有意义，shift number大于等于26可视为0~25的变种）</value><value>
</value><value>rot13:常用的移位加密方法，但加密与解密方式相同，所以解密只需要再进行一次加密。</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>public key
</value><value>
</value><value>it has a way of distributing the key in a using insecure medium.(公钥有一种方法在不安全介质中分发密钥)</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>Insuring Data Intergrity</value><value>
</value><value>
</value><value>Cryptographic Hashing(哈希):map from a message to the hash（散列） or the digest（摘要）
</value><value>
</value><value>takes a large amount of text and reduces it down to some small set of numbers(将大量的文本缩小)</value><value>
</value><value>hashing passwords(哈希密码):when creating a password,run a cryptographic hash on it, store the cryptographic hash.when log in next,just input the plain text to the system,and the system will run the presented password through the same cryptographic hash.
</value><value>
</value><value>hash cannot go backward.(哈希是单向的)，you can go from the frame text to the hash, but you can't go from the hash to the plain text, which is very different than encryption and decryption.(哈希与加密解密的最大不同就是哈希是不可逆的，无法通过散列还原文本),you need to run the plain text through the hash again and then compare</value><value>
</value><value>the system doesn't know what is the password, but it know what is not the password.</value><value>
</value><value>
</value><value>
</value><value>哈希的方法广泛运用与密码的保存和确认识别中，如果运营商能够将密码以明文形式发送给用户，这个运营商的密码机制肯定是不安全的，因为黑客可以通过截获邮件获得密码。运营商应该保存的是密码的哈希值，但是因为哈希的不可逆性，运营商本身也无法知道真正的密码是多少，而用户下次登陆输入密码后将密码的明文进行哈希以后发送给运营商，运营商通过对比保存的密码哈希来确认身份。</value><value>
</value><value>哈希还可以用于确认邮件是否被恶意篡改，方法为，在一段信息的后面加上一个特定的字符串，对整个文本进行哈希加密，然后将哈希的值的前几位加在文本后面。文本接收方把收到的文本后面加上特定字符串后进行哈希，如果文本被恶意篡改过，哈希值的前几位会不同</value><value>
</value><value>
</value><value>
</value><value>
</value><value>WEEK 9</value><value>
</value><value>Securing Web Connections</value><value>
</value><value>
</value><value>public key encryption(公钥加密)，it relies on two asymmetric keys(依赖于两个不对称的键).There is a public key, which is actually, does not need any protection whatsoever, and a private key(私钥).You generate the public key and the private key. You send out the public key, the public is used to do the encryption. And then private key is used to do the decryption. And they're related mathematically(在数学上是相关的)</value><value>
</value><value>if you're going to use public private key encryption, you have to generate a pair.（公钥私钥必须成对存在）</value><value>
</value><value>choose a random number really big--&gt;look around for a nearby prime number and you choose two of those(选择两个附近的质数)--&gt;multiply them--&gt;through some calculations, you compute the public and the private keys from that large number.</value><value>
</value><value>破解公钥加密的难点在于，很难计算出一个很大的数是由哪两个也很大质数相乘得到的，而文件的接收方由于知道其中的一个质数，解密起来非常简单。</value><value>
</value><value>Message was encrypt by application protocols(such as  HTTP).it stay encrypted all the way through the entire network.all of the sequencing and re-transmission that happens in the TCP layer(所有的排序和传输都发生在TCP层).The rest of the internet just move the data.</value><value>
</value><value>Transport Layer Security(SSL、HTTPS):it's between the TCP layer and the application layer.</value><value>
</value><value>
</value><value>Identity on the Web</value><value>
</value><value>
</value><value>Secure Socket Layer, an public private key encryption.</value><value>
</value><value>在TCP层和application层之间的SSL层是一个为安全提供保障的部分，为网络连接提供安全的网络接口。运用了SSL的超文本传输协议就是HTTPS。SSL后来进化为TLS。</value><value>
</value><value>the certificate authority which is a trusted, third-party that signs these certificates(受信任的证书颁发机构，第三方签署了证书，以确认对话的对象是不是真正的服务器)</value><value>
</value><value>

</value></text><lastUpdated>2019-04-09 00:20</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/archive/2020/09/05.html</url><title>2020 年 9月 5 日 随笔档案 - 氧化氟碳 - 博客园</title><text></text><lastUpdated>None</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/p/10393536.html</url><title>寒假训练营第三次作业 - 氧化氟碳 - 博客园</title><text><value>
    </value><value>part1网络课程学习</value><value>
</value><value>学习福州大学网络课程 网络空间安全概论，形成学习笔记，发布专门博客，至少完成第五章的视频学习。</value><value>
</value><value>传送门--&gt;</value><value>2019寒假训练营第三次作业part1-网络空间安全概论第五章</value><value>
</value><value>part2实验题</value><value>
</value><value>背景</value><value>
黑客风波过后，一切又恢复了正常。但你总觉得有些不安，按照之前的方法：把所有请求都记录下来，的确能很准确地显示所有用户的请求情况。但是请求实在太多，把它们都记下来，需要花费巨大的空间来存储，导致许多预算用在了购买记录请求的空间上，而且服务器的速度也下降不少。有没有更好的办法？你觉得自己遇到了瓶颈，但别人肯定也遇到过同样的问题，何不借鉴别人的方法？查阅文献过程中，果然，发现一种叫做 sketch 的技术十分火热，可以解决这个问题，它可以显著地降低空间的使用。你很兴奋，你想尽快地把这个技术部署到服务器上。</value><value>
</value><value>传送门--&gt;</value><value>2019寒假训练营第三次作业part2 - 实验题</value><value>

</value></text><lastUpdated>2019-02-18 00:21</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/archive/2019/02/18.html</url><title>2019 年 2月 18 日 随笔档案 - 氧化氟碳 - 博客园</title><text></text><lastUpdated>None</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/p/10423782.html</url><title>寒假训练营第四次作业 - 氧化氟碳 - 博客园</title><text><value>
    </value><value>使用miniedit工具搭建拓扑的过程截图及说明(5')</value><value>
</value><value>
</value><value>这部分主要参考了-&gt;</value><value>Ubuntu16.04源码安装Mininet</value><value>
</value><value>
</value><value>
</value><value>通过修改参数连接控制器的详细过程截图及说明(20')</value><value>
</value><value>
</value><value>
</value><value>这步当中有一段曲折的故事，ping了半天都ping不通，才发现忘记了s1和s2之间的链路</value><value>
</value><value>
</value><value>
</value><value>连接控制器的过程遵循什么协议？简单描述一下这个过程(15')</value><value>
遵循Openflow协议。</value><value>
首先建立连接，经过类似tcp三次握手以后，建立底层的通信。</value><value>
然后一般要经过Hello、Features Request、Features Reply、Set config、PacketIn、PacketOut</value><value>
运行生成的脚本，检测主机之间是否互通(pingall)，并截图(10')</value><value>
</value><value>
</value><value>把生成的python脚本上传到github仓库中(5')</value><value>
保存的时候出了些问题，貌似是配置文件出了点问题，得到的脚本是空文件。在百度谷歌上也找不到解决方法，所以没有办法了&gt;_&lt;</value><value>
</value><value>
</value><value>本次训练营总结(30'):</value><value>
你觉得自己收获到了什么(包括知识、技能、意愿)？如何体现？(20')</value><value>
学习到mininet、GitHub、Ubuntu、count-min-sketch、tcpdump、GitHub、Linux、网络空间安全方面的相关知识等；巩固了python和c语言，强化了自己的逻辑思维能力和知识整合能力；明白了百度Google的强大、发现了很多以前没有的学习途径和平台，比如各种技术论坛、bilili、YouTube等等;面对一个问题不能盲目地想要马上解决，而是应该在整体上对解法有一个把握，形成思路，并把问题拆分后逐一解决......</value><value>
自己还存在着那些不足或者遗憾？(10')</value><value>
认识到了自己对计算机、对互联网的了解甚少；英语能力不足导致了在Google和在外网查找解决问题的方法以及看YouTube视频的时候障碍颇多；自己解决能力的问题还是比较薄弱，常常一个小问题需要很长时间；专注力有待提高，做作业的过程总忍不住看看手机；对问题的分析能力，以及对问题的划分能力有所不知，常常会卡在两个分块问题之间......</value><value>
</value><value>这两天得了胃寒性感冒，身体状态不是很好，所以这次作业比较完成得粗糙，抱歉。</value><value>

</value></text><lastUpdated>2019-02-24 21:17</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/archive/2020/09/16.html</url><title>2020 年 9月 16 日 随笔档案 - 氧化氟碳 - 博客园</title><text></text><lastUpdated>None</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/p/10393050.html</url><title>2019寒假训练营第三次作业part2 - 实验题 - 氧化氟碳 - 博客园</title><text><value>
    </value><value>热身题</value><value>
</value><value>服务器正在运转着，也不知道这个技术可不可用，万一服务器被弄崩了，那损失可不小。</value><value>
所以, 决定在虚拟机上试验一下，不小心弄坏了也没关系。需要在的电脑上装上虚拟机和linux系统</value><value>
安装虚拟机(可参考Vmware、Virtual Box等)</value><value>
安装ubuntu系统(推荐安装16.04版本)</value><value>
写一个helloworld程序，在ubuntu系统上编译运行</value><value>
（你可能需要了解linux系统的终端和一些基本命令、文本编辑工具nano、如何编译代码、运行程序）</value><value>
</value><value>
</value><value>1.安装虚拟机Vmware：在官网下载页面选择workstation pro，下载并安装。</value><value>
</value><value>
</value><value>
</value><value>运行workstation pro节目如下</value><value>
</value><value>
</value><value>
</value><value>2.安装Ubuntu系统</value><value>
安装系统，以及配置c、c++编译器主要参考了以下两篇博文：</value><value>
</value><value>win10安装内置Ubuntu系统</value><value>
</value><value>Windows10内置Ubutnu配置C/C++编译环境</value><value>
</value><value>3.在VMware上创建Ubuntu虚拟机主要参考了</value><value>Vmware虚拟机安装Ubuntu 16.04 LTS(长期支持)版本+VMware tools安装</value><value>
</value><value>4.在Ubuntu系统上编译运行hello world程序</value><value>
</value><value>先在桌面添加名为1.cpp的helloworld程序</value><value>
</value><value>在Ubuntu系统上运行</value><value>
</value><value>
</value><value>
</value><value>基本题</value><value>
</value><value>了解新技术</value><value>
</value><value>众多sketch的技术中，Count-min sketch 常用也并不复杂，但你可能需要稍微了解一点点散列的知识。从它入手不失为一个好选择，把它记录在你的技术博客上：</value><value>
</value><value>
</value><value>1.简单描述什么是sketch</value><value>
</value><value>sketch是基于哈希的数据结构，通过合理设置哈希函数（也称散列函数），在将数据进行哈希运算后（可能包含多次哈希运算，即多重哈希，目的是提高精确度），将具有相同哈希值的键值数据存入相同的特定区域内，以减少空间开销。将各个区域内的数据值作为测量结果，存在一定的误差，但可以使用各种方式减小误差。</value><value>
</value><value>2.描述Count-min sketch的算法过程
</value><value>
</value><value>摘自维基百科：In computing, the count–min sketch (CM sketch) is a probabilistic data structure that serves as a frequency table of events in a stream of data. It uses hash functions to map events to frequencies, but unlike a hash table uses only sub-linear space, at the expense of overcounting some events due to collisions.（ 在计算中，count-min sketch（CM sketch）是一种概率数据结构，用作数据流中事件的频率表。它使用散列函数将事件映射到频率，但不像散列表仅使用子线性空间，代价是由于冲突导致一些事件过度计数。）</value><value>
</value><value>目的：统计一个实时的数据流中元素出现的频率，并且准备随时回答某个元素出现的频率，不需要的精确的计数。</value><value>
</value><value>技巧：因为储存所有元素的话太耗费内存空间，所有不存储所有的不同的元素，只存储它们Sketch的计数。</value><value>
</value><value>实现大致过程：
</value><value>
</value><value>建立一个1~x的数组，作为储存计数的载体。</value><value>
</value><value>对于一个新元素，哈希到0~x中的一个数x0，作为该元素的数组索引。</value><value>
</value><value>查询元素出现频率时，返回元素对于数组索引中储存的数即可。</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>实现新技术(30')</value><value>
</value><value>大致了解了Count-min sketch，接下来就需要实现它了。本着不需要重复造轮子的思想，你上github一查，果然发现了相关代码。</value><value>
并不需要深刻理解代码，你只需要会用，你的目标是在虚拟机上跑通Count-min sketch：</value><value>
</value><value>
</value><value>
</value><value>1.克隆一种版本（python或者c语言）的代码，大致了解如何使用这个代码，在ubuntu系统上编译。自己任意编写一个小测试，成功运行这个代码。</value><value>
</value><value>
</value><value>
</value><value>通过pip安装countminsketch0.2</value><value>
</value><value>
</value><value>
</value><value>
</value><value>在GitHub上找到了一个countminsketch项目</value><value>
</value><value>
</value><value>
</value><value>
</value><value>因为代码比较久远，需要把xrange()函数更替为range()函数</value><value>
</value><value>
</value><value>
</value><value>出现Unicode-objects must be encoded before hashing问题时，发现是update() 方法必须指定要指定编码格式，否则会报错。应在update（）内添加.encode("utf8")</value><value>
</value><value>
</value><value>
</value><value>在网络上下载《飘》的英文版</value><value>
</value><value>
</value><value>
</value><value>编写程序，统计文中的地名“tala”的出现次数</value><value>
</value><value>
</value><value>
</value><value>
</value><value>运行成程序三次，结果分别为</value><value>
</value><value>
</value><value>
</value><value>
</value><value>2.你也可以自己实现Count-min sketch。</value><value>
</value><value>
</value><value>
</value><value>获取用户请求(15')</value><value>
</value><value>现在需要获取用户的请求信息，其实请求就是网络传输的数据包，可以使用自己的网络环境来模拟服务器的请求,使用工具来捕获这个数据包：</value><value>
</value><value>
</value><value>
</value><value>1.安装并使用抓包工具tcpdump</value><value>
</value><value>
</value><value>
</value><value>2.输入tcpdump -n 获取数据包的信息</value><value>
</value><value>
</value><value>
</value><value>在这部分中，因为Ubuntu的版本原因，卡了很久。最后改成Ubuntu16.04后才能顺利抓包。&gt;_&lt;</value><value>
</value><value>本来是像抓100000条内容的，但因为种种原因，不得已中断了两次，最后只有80000多条</value><value>
</value><value>
</value><value>
</value><value>
</value><value>3.使用linux 重定向的方法把该信息用文本文件存起来，文件命名为 pakcet_capture.txt。</value><value>
</value><value>
</value><value>
</value><value>
</value><value>编写一个py程序，处理得到的数据</value><value>
</value><value>
</value><value>
</value><value>
</value><value>得到的Request.txt</value><value>
</value><value>
</value><value>
</value><value>
</value><value>测试新技术</value><value>
</value><value>完事具备，只欠东风：</value><value>
</value><value>
</value><value>用跑通的Count-min sketch程序读文件，获得最后的处理结果，请求大小超过阈值T认定为黑客，此处T自己定义。对于你所完成题目，把实现思路和实现结果记录在博客中，把代码提交到github的仓库上。</value><value>
稍微改造一下第二次作业中的代码，添加了count-min sketch算法
</value><value>
</value><value>
</value><value>地址</value><value>
</value><value>
</value><value>
</value><value>
</value><value>得到的名单</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>开放题(50')</value><value>
</value><value>
</value><value>理论部分(25')
</value><value>
</value><value>
</value><value>解释为什么 sketch 可以省空间</value><value>
</value><value>
</value><value>count-min sketch算法使用了hash函数，通过压缩映射，使得散列值的空间远远小于输入值的空间。</value><value>
</value><value>
</value><value>
</value><value>
</value><value>用流程图描述Count-min sketch的算法过程</value><value>
</value><value>
</value><value>
</value><value>
</value><value>拿它和你改进后方法进行对比，分析优劣</value><value>
</value><value>
</value><value>优点：引入了count-min sketch后，很大程度上减小了空间占用和处理速度。</value><value>
</value><value>缺点：
</value><value>
</value><value>可能是笔者不是很懂count-min sketch算法中m,d值的设置，抑或是算法本身的原因，得到的数据不甚准确，每次计算得到的值基本不同。但因为是针对大体量数据进行的计算，一些误差可以看淡甚至忽略不计。但若是对较少数据量的计算，误差则会严重影响精度（例如本文中给出的，对《飘》中地名的统计，难以得到较为准确的数据）</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>吐槽Count-min sketch</value><value>
</value><value>
</value><value>笔者在GitHub上找到的代码过于久远，py中的xrange()函数已经被弃用了，需要手动改成range()。</value><value>
</value><value>readme文件有些地方说得晦涩难懂，花了一些功夫才搞懂怎么使用。</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>实验部分(25')
</value><value>
</value><value>1.here--&gt;</value><value>整合了两个步骤，减少了代码读写，由packet_capture直接得到结果</value><value>
</value><value>
</value><value>改进中的问题：
</value><value>
</value><value>整合后代码的运算结果与原来的结果有出入，可能的原因是原算法的第一步筛选过程中错误筛除了一些内容。</value><value>
</value><value>
</value><value>新程序出现了一些莫名其妙的数组越界错误，但检查后并未发现packet_capture.txt中有存在单行内容因为无空格以至于split()函数无法分割的问题。所以加了一个len(list())&gt;a绕开这个问题</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>2.实时处理请求还未能实现，
</value><value>
</value><value>主要障碍有：
</value><value>
</value><value>是不懂得如何在程序中启动tcpdump进行抓包</value><value>
</value><value>因为Ubuntu虚拟机上py配置出了一些问题，不得已将packet_capture.txt文件移动到win10下进行处理</value><value>
</value><value>
</value><value>
</value><value>对这部分的一些想法：
</value><value>
</value><value>基本流程应该是：
</value><value>
</value><value>数据生成-&gt;实时采集-&gt;将数据保存在缓存中-&gt;实时计算-&gt;计算结果存储-&gt;被查询</value><value>
</value><value>
</value><value>
</value><value>引入一些大数据处理框架。大数据处理系统可分为批式大数据和流式大数据两类。其中，批式大数据又被称为历史大数据，流式大数据又被称为实时大数据。流式大数据系统包括了：Spark Streaming、Storm、Flink等</value><value>
</value><value>可否模仿CentOS与wireshark之间利用PIPE接口实现数据从虚拟机上实时拷贝到win系统中进行处理</value><value>
</value><value>这篇文章中提到了关于python调用tcpdump的相关内容</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>

</value></text><lastUpdated>2019-02-18 00:03</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/p/13681302.html</url><title>2020软工第二次作业 - 氧化氟碳 - 博客园</title><text><value>
    </value><value>
</value><value>
</value><value>
</value><value>这个作业属于哪个课程</value><value>
</value><value>软件工程2020秋</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>这个作业要求在哪里</value><value>
</value><value>第二次作业（个人编程作业）</value><value>
</value><value>
</value><value>
</value><value>这个作业的目标</value><value>
</value><value>热身+练手，锻炼现学现用的能力</value><value>
</value><value>
</value><value>
</value><value>学号</value><value>
</value><value>031804103</value><value>
</value><value>
</value><value>
</value><value>
</value><value>PSP表格</value><value>
</value><value>
</value><value>
</value><value>
</value><value>PSP2.1</value><value>
</value><value>Personal Software Process Stages</value><value>
</value><value>预估耗时（分钟）</value><value>
</value><value>实际耗时（分钟）</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>Planning</value><value>
</value><value>计划</value><value>
</value><value>20</value><value>
</value><value>15</value><value>
</value><value>
</value><value>
</value><value>Estimate</value><value>
</value><value>估计这个任务需要多少时间</value><value>
</value><value>10</value><value>
</value><value>10</value><value>
</value><value>
</value><value>
</value><value>Development</value><value>
</value><value>开发</value><value>
</value><value>300</value><value>
</value><value>420</value><value>
</value><value>
</value><value>
</value><value>Analysis</value><value>
</value><value>需求分析 (包括学习新技术)</value><value>
</value><value>120</value><value>
</value><value>150</value><value>
</value><value>
</value><value>
</value><value>Design Spec</value><value>
</value><value>生成设计文档</value><value>
</value><value>60</value><value>
</value><value>75</value><value>
</value><value>
</value><value>
</value><value>Design Review</value><value>
</value><value>设计复审</value><value>
</value><value>30</value><value>
</value><value>20</value><value>
</value><value>
</value><value>
</value><value>Coding Standard</value><value>
</value><value>代码规范 (为目前的开发制定合适的规范)</value><value>
</value><value>30</value><value>
</value><value>30</value><value>
</value><value>
</value><value>
</value><value>Design</value><value>
</value><value>具体设计</value><value>
</value><value>60</value><value>
</value><value>60</value><value>
</value><value>
</value><value>
</value><value>Coding</value><value>
</value><value>具体编码</value><value>
</value><value>120</value><value>
</value><value>120</value><value>
</value><value>
</value><value>
</value><value>Code Review</value><value>
</value><value>代码复审</value><value>
</value><value>30</value><value>
</value><value>30</value><value>
</value><value>
</value><value>
</value><value>Test</value><value>
</value><value>测试（自我测试，修改代码，提交修改）</value><value>
</value><value>120</value><value>
</value><value>150</value><value>
</value><value>
</value><value>
</value><value>Reporting</value><value>
</value><value>报告</value><value>
</value><value>90</value><value>
</value><value>120</value><value>
</value><value>
</value><value>
</value><value>Test Report</value><value>
</value><value>测试报告</value><value>
</value><value>60</value><value>
</value><value>60</value><value>
</value><value>
</value><value>
</value><value>Size Measurement</value><value>
</value><value>计算工作量</value><value>
</value><value>20</value><value>
</value><value>20</value><value>
</value><value>
</value><value>
</value><value>Postmortem &amp; Process Improvement Plan</value><value>
</value><value>事后总结, 并提出过程改进计划</value><value>
</value><value>30</value><value>
</value><value>25</value><value>
</value><value>
</value><value>
</value><value>合计</value><value>
</value><value>
</value><value>1100</value><value>
</value><value>1305</value><value>
</value><value>
</value><value>
</value><value>
</value><value>解题思路</value><value>
</value><value>初见</value><value>
</value><value>说实话，这次出作业之前，我属实被隔壁K班的作业吓到了，所以第一眼看到这次作业我是往复杂的方向想的。第一次看题的时候比较仓促，下载了数据，大概看了知道是大数据统计题（作为大数据专业的，这次作业如此挣扎，惭愧...），以为要做的是GitHub各种commit变化情况，因为这个数据包含的信息实在是太多了。但是仔细看题后，发现其实关注的信息类型只有PushEvent、IssueCommentEvent、IssuesEvent、PullRequestEvent四种，这倒是很符合大数据5V特性（Volume、Variety、Value、Velocity、Veracity）里面的</value><value>价值密度低</value><value>。</value><value>
把题目完整读完以后，发现还有python的示例代码，对这次作业产生了一种：代码不难，主要是熟悉git、PSP、code style的感觉。后来证明我只对了一半，低估了代码难度。</value><value>
</value><value>沉思</value><value>
</value><value>这个小标题正好是我很喜欢的一个曲子，曾经苦练过几个月，也是我高三时期的起床铃声，顺便分享一个我最喜欢的版本：</value><value>
</value><value>
接下来主要是安排作业计划和思考解题思路，由于要参加数学建模，作业计划被安排到了作业截止周才开工，所以这次作业做的比较仓促的原因主要在于我低估了难度。</value><value>
</value><value>
</value><value>
</value><value>idea one：Sketch</value><value>
</value><value>
</value><value>
</value><value>大数据量的统计，首先想到了之前看过的一些paper，比如 </value><value>An Improved Data Stream Summary:The Count-Min Sketch and Its Applications</value><value>，用来做一些有损统计能很有效降低数据量和加速查询，还可以在精度和空间开销之间做权衡，我也实现/跑过几个类似的demo，所以想到这个idea我还是很兴奋的。</value><value>
但是后来再读了一遍题目并重读了paper以后，发现本题的主要问题在于大数据量的读取，处理后的数据本身就是比较小的，查询的优化空间也不大，最重要的是本题似乎不允许有损统计。</value><value>
</value><value>
</value><value>
</value><value>idea two：Hadoop</value><value>
</value><value>
</value><value>
</value><value>回到大数据统计的问题上，，想到了本题少次大量读入的特点，我就想到了之前玩过的HDFS（Hadoop Distance File System）和MapReduce。分布式的存储和计算对大数据量的处理任务还是很有效的，无奈并不很精通Hadoop，这个作业也不是简单的word count，测试平台有没有这种特殊的环境也是个问题。</value><value>
</value><value>
</value><value>
</value><value>idea three：Python</value><value>
</value><value>
</value><value>
</value><value>前两个idea被pass以后，似乎也想不到什么有创意的idea了，所以只好选择比较中规中矩的思路，一方面是自己比较熟悉py，另一方面是时间比较紧，就直接参考（xiu gai）样例代码了。</value><value>
看了看样例代码，发现已经是功能完整的版本了，只是没有注释，看起来比较费工夫。那问题就变成了，如何提速样例代码的速度</value><value>
</value><value>设计实现过程</value><value>
</value><value>额,其实不能说是设计实现过程，而是找漏洞&amp;加速的过程。下面涉及到的测试截图的数据量都是大概300MB。</value><value>
下面是大致的流程图</value><value>
</value><value>
</value><value>前期准备</value><value>
</value><value>涉及到了json的读写、命令行的解析，所以初步找了些资料学习一下</value><value>
</value><value>
</value><value>json教程</value><value>
</value><value>argparse教程</value><value>
</value><value>
</value><value>分段测试时间，寻找瓶颈</value><value>
</value><value>这个小部分的主要思路是大致把样例代码的初始化部分分块，分别测试耗时。稍微测试了一下样例代码，发现读取文件和处理文件耗时明显很高。</value><value>
</value><value>
</value><value>所以接下来的主要优化工作在于这两部分的改良（mo gai）。</value><value>
</value><value>处理数据</value><value>
</value><value>在这部分发现了参考代码的一个破绽（不知道是不是故意的嗷），在阅读代码的过程中发现了这样两个函数：</value><value>
</value><value>    def __parseDict(self, d: dict, prefix: str):
        _d = {}
        for k in d.keys():
            if str(type(d[k]))[-6:-2] == 'dict':
                _d.update(self.__parseDict(d[k], k))
            else:
                _k = f'{prefix}__{k}' if prefix != '' else k
                _d[_k] = d[k]
        return _d
    def __listOfNestedDict2ListOfDict(self, a: list):
        records = []
        for d in a:
            _d = self.__parseDict(d, '')
            records.append(_d)
        return records
</value><value>
</value><value>仔细阅读可以发现，这两个函数其实是嵌套的，相当于一个二重循环。其主要作用是把一个嵌套的字典传进来，返回一个整理过的非嵌套的字典，比较便于访问。但是这样做的代价是对于整个数据二重循环了一遍，应该是处理文件阶段的一个比较大的瓶颈，为了考证这个猜想，进一步对处理数据部分再次拆分测试时间。将处理数据进一步拆分为重构数据和统计数据阶段。</value><value>
</value><value>
</value><value>可以看到，rebuild data的阶段占据了处理数据的绝大部分时间。</value><value>
其实这两个函数并不是必须的，完全可以在统计阶段直接访问嵌套字典，而不需要重构数据。</value><value>
</value><value>
</value><value>对处理数据的代码进行修改，并free掉上述两个函数和调用这两个函数的语句，再次进行实验：</value><value>
</value><value>
</value><value>速度提升很明显，把总用时缩短到了原来的一半，处理数据的耗时大幅缩短。</value><value>
</value><value>读取文件</value><value>
</value><value>读取文件部分没有发现什么大问题，所以就是提速的问题了。</value><value>
</value><value>
</value><value>
</value><value>idea one：mmap</value><value>
</value><value>久闻mmap大名，据说加速的效果很可观。于是找了个blog学习了一下。</value><value>
</value><value>mmap参考blog</value><value>
</value><value>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</value><value>
摸索了一段时候以后尝试着实现了一下，代替了读文件后的一些解析操作的操作，效果还不错，总时间大概缩短了1s。</value><value>
</value><value>
</value><value>
</value><value>
</value><value>idea two：多线程</value><value>
</value><value>在这之前，修改数据量都是直接批量复制多个文件，也就是目录下存在多个json文件，那么可不可以让他并行读取呢？之前在Java上做过多线程读取文件，所以也想把多线程用到读文件的部分去。这个idea其实很早就想到了，但是觉得不太好实现，事实上经过了一段曲折后，费了很大劲并没有多少提高，后来才知道python的多线程，并不是真正的并发。所以也就引出了下一个idea。</value><value>
</value><value>
</value><value>
</value><value>idea three：多进程</value><value>
</value><value>既然多线程不可以，那就试试多进程咯，这个总可以了吧。而且，这边并不知道有多少个文件，所以并不能用单纯的多进程，而需要进程池（multiprocessing pool）。这部分比多线程的实现更加曲折和费劲，最后代码也被我大量魔改，所以难以（lan de）复现多线程的代码和结果了。折腾了很久，重构了很多代码。这边为了解决线程调用函数返回的问题，干脆在线程中用写文件的形式保存结果，因为写文件的开销很小，进程池处理结束后再去文件读处理后的结果，这一步也顺便在写文件的过程中实现了前面提到了嵌套函数二重循环的功能，在写入循环中实现了相同功能。最后得到了一个比较理想的结果：</value><value>
</value><value>
</value><value>
</value><value>
</value><value>代码说明</value><value>
</value><value>读取文件，主要通过进程池调用</value><value>
</value><value>def readFile(self, f, dict_address): 
    json_list = []
    if f[-5:] == '.json':
        json_path = f
        x = open(dict_address + '\\' + json_path, 'r', encoding='utf-8')
        with mmap.mmap(x.fileno(), 0, access=mmap.ACCESS_READ) as m:
            m.seek(0, 0)
            obj = m.read()
            obj = str(obj, encoding="utf-8")
            str_list = [_x for _x in obj.split('\n') if len(_x) &gt; 0]
            for _str in str_list:
                try:
                    json_list.append(json.loads(_str))
                except:
                    pass
        self.saveJson(json_list, f)
</value><value>
</value><value>读文件后对进程的处理结果保存在文件中</value><value>
</value><value>def saveJson(self, json_list, filename): 
    batch_message = []
    for item in json_list:
        if item['type'] not in ["PushEvent", "IssueCommentEvent", \
        "IssuesEvent", "PullRequestEvent"]:
            continue
        batch_message.append({'actor__login': item['actor']['login'],\
         'type': item['type'], 'repo__name': item['repo']['name']})
    with open('json_temp\\' + filename, 'w', encoding='utf-8') as F:
        json.dump(batch_message, F)
</value><value>
</value><value>单元测试</value><value>
</value><value>安装coverage：</value><value>pip install coverage</value><value>
然后找了个</value><value>测试教程</value><value>
测试了一下初始化函数</value><value>
</value><value>
</value><value>覆盖率为64%，但是我在查看具体的报告时发现，</value><value>覆盖率测试把进程池调用的函数模块认定为missing</value><value>.....所以实际上的覆盖率要高一点。</value><value>
测试：</value><value>
</value><value>
</value><value>
</value><value>代码规范</value><value>
</value><value>my code style</value><value>
</value><value>总结</value><value>
</value><value>相当曲折和艰难的一次作业，时间比较赶，所以各方面都比较仓促和粗糙。不过也接触了很多之前没用过的工具，提高了我的专注程度，感觉就像延续了几天的建模比赛的节奏。之前的coding都没有代码规范的概念，也不会去关注性能（除了之前打oj）。总的来说收获还是蛮大的，过程中学到的东西和积累的快速学习能力都是宝贵财富。</value><value>
同时也深刻理解到了python的缺点：性能。虽然打起来很快很舒服，但是终究是比不过C++和Java的。</value><value>

</value></text><lastUpdated>2020-09-16 20:50</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/p/13735287.html</url><title>2020软工第三次作业（结对编程第一次作业） - 氧化氟碳 - 博客园</title><text><value>
    </value><value>
</value><value>
</value><value>
</value><value>这个作业属于哪个课程</value><value>
</value><value>软件工程2020秋</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>这个作业要求在哪里</value><value>
</value><value>第三次作业（结对编程第一次作业）</value><value>
</value><value>
</value><value>
</value><value>这个作业的目标</value><value>
</value><value>锻炼协作能力，提出初步解决方案</value><value>
</value><value>
</value><value>
</value><value>学号</value><value>
</value><value>031804103</value><value>、</value><value>051806129</value><value>
</value><value>
</value><value>
</value><value>
</value><value>PSP表格</value><value>
</value><value>
</value><value>
</value><value>
</value><value>PSP</value><value>
</value><value>Pair programming Process Stages</value><value>
</value><value>预估耗时（分钟）</value><value>
</value><value>实际耗时（分钟）</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>Planning</value><value>
</value><value>计划</value><value>
</value><value>15</value><value>
</value><value>15</value><value>
</value><value>
</value><value>
</value><value>Estimate</value><value>
</value><value>估计这个任务需要多少时间</value><value>
</value><value>10</value><value>
</value><value>10</value><value>
</value><value>
</value><value>
</value><value>Development</value><value>
</value><value>开发</value><value>
</value><value>240</value><value>
</value><value>210</value><value>
</value><value>
</value><value>
</value><value>Analysis</value><value>
</value><value>需求分析 (包括学习新技术)</value><value>
</value><value>45</value><value>
</value><value>30</value><value>
</value><value>
</value><value>
</value><value>Design Spec</value><value>
</value><value>生成设计文档</value><value>
</value><value>45</value><value>
</value><value>45</value><value>
</value><value>
</value><value>
</value><value>Design Review</value><value>
</value><value>设计复审</value><value>
</value><value>30</value><value>
</value><value>25</value><value>
</value><value>
</value><value>
</value><value>Coding Standard</value><value>
</value><value>代码规范 (为目前的开发制定合适的规范)</value><value>
</value><value>0</value><value>
</value><value>0</value><value>
</value><value>
</value><value>
</value><value>Design</value><value>
</value><value>具体设计</value><value>
</value><value>120</value><value>
</value><value>120</value><value>
</value><value>
</value><value>
</value><value>Coding</value><value>
</value><value>具体编码</value><value>
</value><value>0</value><value>
</value><value>0</value><value>
</value><value>
</value><value>
</value><value>Code Review</value><value>
</value><value>代码复审</value><value>
</value><value>0</value><value>
</value><value>0</value><value>
</value><value>
</value><value>
</value><value>Test</value><value>
</value><value>测试（自我测试，修改代码，提交修改）</value><value>
</value><value>20</value><value>
</value><value>15</value><value>
</value><value>
</value><value>
</value><value>Reporting</value><value>
</value><value>报告</value><value>
</value><value>0</value><value>
</value><value>0</value><value>
</value><value>
</value><value>
</value><value>Test Report</value><value>
</value><value>测试报告</value><value>
</value><value>30</value><value>
</value><value>30</value><value>
</value><value>
</value><value>
</value><value>Size Measurement</value><value>
</value><value>计算工作量</value><value>
</value><value>20</value><value>
</value><value>20</value><value>
</value><value>
</value><value>
</value><value>Postmortem &amp; Process Improvement Plan</value><value>
</value><value>事后总结, 并提出过程改进计划</value><value>
</value><value>20</value><value>
</value><value>20</value><value>
</value><value>
</value><value>
</value><value>合计</value><value>
</value><value>
</value><value>595</value><value>
</value><value>530</value><value>
</value><value>
</value><value>
</value><value>
</value><value>背景</value><value>
</value><value>
</value><value>学长学姐去哪儿——了解实验室或社团历史上的那些学长学姐们的去向和现状</value><value>
了解实验室学长们去向的现状：</value><value>
除了实验室群里长期潜水或偶尔冒泡的学长、导师口中的零星去向、临近的学长，似乎就无法了解了。好久以前的没见过的学长们，去了哪里。这不仅仅是?是否?选择这个实验室的依据之一，还是今后找工作的内推的重要支柱。可惜现状就不是很明确和了解，知晓的渠道也很有限。</value><value>
学长们其实也很想了解学弟们现在在做什么研究，有没有什么擅长的技能，比如会某个研究方向或数学建模技能的，也很希望能帮忙协助内推，比如这位学长，就只能给我发消息，也无法有效传递。</value><value>
另外，建一个实验室群，也不是很方便，因为在群里，你也不好意思经常问：学长们，你们在哪啊。</value><value>
甚至，等你工作了，和你同一个公司或一个组的同事，可能就是实验室同门，你们都相见不相识，多遗憾。</value><value>
</value><value>
</value><value>题目</value><value>
</value><value>
</value><value>请你和对友设计一套信息化的解决方案，兼顾实用性、有效性、安全性、隐私性、封闭性。</value><value>
可以是一个软件、APP或小程序，不仅仅包含主要界面和功能的原型，还需要描述不同角色用户，如何注册、添加、删除、认证加入等，从使用频率、使用便利度、使用有效性等角度出发，考虑如何维护该系统，如何确保安全性、隐私性、时效性和相对封闭性等，可以是软件化的方式实现上述特点，也可以依赖流程制度实现上述特性。但无论哪一种，都需要你们通过原型图、流程图、文字化方案来描述。清晰呈现一套也许你们也需要、客户也需要的完美的解决方案。</value><value>
</value><value>
</value><value>GitHub</value><value>
</value><value>
</value><value>讨论剪影</value><value>
</value><value>
</value><value>解决方案</value><value>
</value><value>主要参照《构建之法》第八章中所介绍的NABCD模型提出我们的解决方案。</value><value>
</value><value>N:需求</value><value>
</value><value>站在用户的角度思考与分析问题。本问题主要面向三类用户：</value><value>老师、在校生、毕业生</value><value>
</value><value>
</value><value>
</value><value>老师</value><value>
</value><value>
</value><value>
</value><value>长期以来扮演着在校生和毕业生之间互相认识的媒介，但是科研任务繁忙，也无法完全记住每个同学的技能树和具体的研究进度，导致有些时候在校生和毕业生之间的交流难以成行。</value><value>
</value><value>
</value><value>
</value><value>在校生</value><value>
</value><value>
</value><value>
</value><value>在校生处在求学科研找工作的多重压力下，急需同门学长学姐分享科研经验经验或者帮助内推。然而在校生缺乏了解同门前辈的渠道，不知道前辈们曾经的研究方向是什么、在何处工作、是否能提供帮助。不管是一个一个加好友私聊还是直接在群聊中广播提问都不合适。</value><value>
</value><value>
</value><value>
</value><value>毕业生</value><value>
</value><value>
</value><value>
</value><value>毕业生拥有丰富的科研经验，同时也已经在产业界或学术界有了一番耕耘，有些时候遇到难题也希望求助与实验室同门师弟师妹们。然而毕业生离开实验室后难以了解实验室的新人，不知道新人们有何需求、新人们有何技能、新人们的研究方向和进度。更多时候只能通过老师了解哪些师弟师妹拥有自己所需要的技能。</value><value>
</value><value>A:做法</value><value>
</value><value>我们的做法是，让导师成为一个组织者，而不是在校生和毕业生之间认识的媒介，建立一个让所有实验室同门们互相了解的平台。</value><value>
</value><value>
</value><value>在这个平台上大家可以互相了解，除了有个人简介和个人技能树之外，还可以找到每个人在各大社交平台（例如微博、知乎、GitHub等）的ID以互相了解，还可以利用平台提供的用户微信号加好友深入交流。</value><value>
</value><value>平台力求做到相对封闭和安全，只有老师可以新建组织，实验室内部所有人员都可以邀请新人，但是必须经过导师的认证同意，实验室内部信息只有成员可见。</value><value>
</value><value>平台允许一个用户处在多个组织中，且在每个组织中的身份可以不同，例如对于一个博士在读生，在本科阶段和硕士阶段所在实验室中的身份是毕业生，而在博士阶段所在实验室的身份则是在校生。用户发布的问题可以设置为部分所在组织成员可见或所有所在组织成员可见。</value><value>
</value><value>平台力求实现时效性。每个用户可在自己的主页添加个人tag，可以是自己擅长的领域、擅长的技能、当前的研究方向和曾经的研究方向。在发布问题时发布者可以选择添加问题tag，平台将通过公众号推送给具有和问题tag相同或相关个人tag的问题可见成员，提醒有与自己相关的问题发布，而不是向所有实验室成员广播推送消息（这样的话和直接在QQ群、微信群提问没有区别）。</value><value>
</value><value>
</value><value>B:好处</value><value>
</value><value>在校生和毕业生的互相了解可以直接通过平台完成，导师除了前期组织以外无需花费太多的组织成本。成员间可以通过基本资料、技能树、各大社交平台互相了解，还可以通过发布问题的方式具体寻找某些技能拥有者或能提供帮助的用户。</value><value>
平台能够保证相对封闭和安全，进入组织需要导师的认证同意，而组织内部的内容对外部用户不可见，个人资料也只有同一组织的用户才可以访问和查看。</value><value>
</value><value>C:竞争</value><value>
</value><value>优势：</value><value>
</value><value>
</value><value>作为功能型小程序，本方案的封闭性和安全性完全足够，因为只有通过自己微信的小程序才能登录自己的账号，且经过导师认证通过后的实验室内部用户较为可信，个人页面可以发布一些较为详细的个人信息，而不必担心隐私被实验室外部人群窃取。</value><value>
</value><value>特殊的推送功能。通过每个用户添加个人tag，每个提问者在问题中添加问题tag，能够针对问题推送给潜在的目标用户，规避了一部分无效推送造成的垃圾信息。</value><value>
</value><value>
</value><value>劣势：</value><value>
</value><value>
</value><value>组织建立前期因为个人页面不完整、成员数量少，使用体验可能较差，推广任务较为艰巨。</value><value>
</value><value>个人tag的设置与问题tag之间可能有差距，需要设计一个推送算法，尽量减小错误推送和遗漏推送。</value><value>
</value><value>
</value><value>D:推广</value><value>
</value><value>
</value><value>首先在校园内部分实验室做试点，尽量选择已成立多年，在校生和毕业生人数都不少的实验室。在某些奖励机制下，通过试点人群向外发散，因为大组可能包括了许多同时也在其他实验室的成员。</value><value>
</value><value>同时尽量选择多个领域的实验室进行试点，因为用户发散的能力在跨领域中效果极为有限。</value><value>
</value><value>
</value><value>设计原型展示</value><value>
</value><value>动态与消息页面</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>人脉·机遇页面</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>问题区</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>“我的”页面</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>流程图</value><value>
</value><value>老师</value><value>
</value><value>
</value><value>学生（包括在校生和毕业生）</value><value>
</value><value>

</value></text><lastUpdated>2020-09-28 15:56</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/archive/2020/09/28.html</url><title>2020 年 9月 28 日 随笔档案 - 氧化氟碳 - 博客园</title><text></text><lastUpdated>None</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/archive/2020/10/08.html</url><title>2020 年 10月 8 日 随笔档案 - 氧化氟碳 - 博客园</title><text></text><lastUpdated>None</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/p/10322470.html</url><title>寒假训练营第一次作业 - 氧化氟碳 - 博客园</title><text><value>
    </value><value>2019寒假训练营第一次作业</value><value>
</value><value>Q1：在人生技能道路上，你有没有专长的高超技能获取的成功经验？你有什么技能比大多人（超过70%以上）更好？（学习，棋类，球类，乐器，艺术，游戏，......）</value><value>
</value><value>A：小时候半推半就的学了几年的小提琴，学得还算不错，但是当初不是很认真学，限制了技术进一步的提高，但也开发了我的乐感和音准。现在想起来还是蛮后悔当时没有认真学的，也没有把这个爱好坚持下来，到了大学以后才开始享受那种对音乐的感觉。这件事情对我的教训；一是做好一件事兴趣很重要；二是要学会强迫自己，虽然精神和肉体上都很抗拒，但是对自己有好处的事情就应该去争取；三就是坚持，practice makes prefect，不管是练琴还是学习。</value><value>
</value><value>Q2：以后打算读研还是工作，如果读研是选择在国内还是国外，为什么？</value><value>
</value><value>A：会争取读研，应该不会出国读研究生，因为本身英语一般，家里经济状况也只能算是小康。</value><value>
</value><value>Q3：你是怎么学习C语言的？（作业，实验，教材，其他）,与你的高超技能相比，C语言的学习有什么经验和教训？</value><value>
</value><value>A：主要就是平时上课和翁恺老师的mooc配合吧，遇到问题和同学探讨一下。还是觉得练习不够，一些逻辑问题没有花足够的时间去思考。</value><value>
</value><value>Q4：你会设置家里或宿舍的网络的软硬件（路由器）吗？</value><value>
</value><value>A：这个，很惭愧，不是很懂，但是配合说明书和百度应该是没问题的。</value><value>
</value><value>Q5：如果家里或宿舍的网络坏了，你会怎么办？</value><value>
</value><value>A：和舍友研究一下，百度查一查，不行就call客服。</value><value>
</value><value>Q6：编程题链接：</value><value>
</value><value>A：</value><value>GitHub链接</value><value>
git命令操作</value><value>
</value><value>
</value><value>219/1/31更新：</value><value>
对git命令操作的一些补充</value><value>
</value><value>
</value><value>push的时候出现如下错误：</value><value>
To </value><value>https://github.com/Holmze/031804103.git</value><value>
! [rejected]        master -&gt; master (non-fast-forward)</value><value>
error: failed to push some refs to '</value><value>https://github.com/Holmze/031804103.git</value><value>'</value><value>
hint: Updates were rejected because the tip of your current branch is behind</value><value>
hint: its remote counterpart. Integrate the remote changes (e.g.</value><value>
hint: 'git pull ...') before pushing again.</value><value>
hint: See the 'Note about fast-forwards' in 'git push --help' for details.</value><value>
应该是因为云端文件和本地不符导致的，可以先pull在push：</value><value>
先：git pull --rebase origin master</value><value>
然后 git push origin master</value><value>
</value><value>commit的时候，出现：</value><value>
fatal: remote origin already exists.</value><value>
应该先删除origin，改用https连接：</value><value>
$ git remote rm origin</value><value>
</value><value>
</value><value>$ git remote add origin </value><value>https://github.com/Holmze/031804103.git</value><value>

</value></text><lastUpdated>2019-01-26 02:50</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/p/13745347.html</url><title>2020数据采集与融合技术第一次作业 - 氧化氟碳 - 博客园</title><text><value>
    </value><value>数据采集与融合技术第一次作业</value><value>
</value><value>第一题</value><value>
</value><value>题目</value><value>
</value><value>要求：用requests和BeautifulSoup库方法定向爬取</value><value>给定网址</value><value>的数据，屏幕打印爬取的大学排名信息。</value><value>
</value><value>解答</value><value>
</value><value>主要就是BS的基本使用</value><value>
</value><value>code:</value><value>
</value><value>import requests,bs4
url = "http://www.shanghairanking.cn/rankings/bcur/2020"
soup = bs4.BeautifulSoup(requests.get(url).content.decode(),"html.parser")
information = []
for child in soup.find("tbody").children:
    res = child.find_all("td")
    information.append([res[0].text.strip() + "    " + res[1].text.strip() + "    " + res[2].text.strip() + "    " +
                        res[3].text.strip() + "    " + res[4].text.strip()])
print("排名  学校名称  省份  学校类型  总分")
for info in information:
    print(info)
</value><value>
</value><value>result</value><value>
</value><value>
</value><value>第二题</value><value>
</value><value>题目</value><value>
</value><value>要求：用requests和re库方法设计某个商城（自已选择）商品比价定向爬虫，爬取该商城，以关键词“书包”搜索页面的数据，爬取商品名称和价格。</value><value>
</value><value>解答</value><value>
</value><value>选择京东商城，爬书包太没劲了，故选择关键词为“</value><value>RTX3080</value><value>”。</value><value>
</value><value>code</value><value>
</value><value>## 并不完善的一份代码，暂时不支持中文搜索

from urllib.request import urlopen
from bs4 import BeautifulSoup
import re

print("please input:")
item = input()
url = 'https://search.jd.com/Search?keyword='+item ##这玩意好像每天都在变
html = urlopen(url)
bs = BeautifulSoup(html,'html.parser')
goods = bs.find_all("li",{"data-sku":re.compile("\d+")})
for good in goods:
    # print(good.get_text())
    # print(good)
    good_info = good.find("div",{"class":"p-name p-name-type-2"}).find('em').get_text()
    # print(good_info)
    price = good.find('div',{'class':'p-price'}).strong.i.get_text()
    print(good_info.replace("\n","").replace("\t",""),price,"￥")
</value><value>
</value><value>result</value><value>
</value><value>
</value><value>第三题</value><value>
</value><value>题目</value><value>
</value><value>要求：爬取</value><value>一个给定网页</value><value>或者自选网页的所有JPG格式文件。</value><value>
</value><value>解答</value><value>
</value><value>查看具体网址的源代码后发现，主要的图片都在content内部，故使用BeautifulSoup4中的find_all函数在content内搜索图片路径。</value><value>
图片路径包括内链接（以“/...”开头，是给定网站内部的图片）与外链接（以“HTTP...”开头，是其他网站的图片），故对两种图片链接分类处理。</value><value>
得到所有图片的链接后，使用</value><value>requests.get()</value><value>获取图片数据。</value><value>
</value><value>code</value><value>
</value><value>from urllib.request import urlopen
from bs4 import BeautifulSoup
# from urllib import urlretrieve
import requests

url = 'http://xcb.fzu.edu.cn/'
html = urlopen(url)
bs = BeautifulSoup(html,'html.parser')
name = 1
for imgs in bs.find('div',{'class':'content'}).find_all('img'):
    # if 'src' in imgs.attrs:
    #     print(imgs)
    img = imgs['src']
    if img[-3:] != 'gif':
        if img[:4] == 'http':
            path = img
        else:
            path = url+img
    else:
        continue
    print(path)
    # img_data = urlopen(path)
    # img_data = img_data.read()
    img_file = requests.get(path).content
    with open("Object1：爬取学生信息\images/"+str(name)+".jpg","wb") as f:
        f.write(img_file)
        f.close()
        print(name,"over")
        name += 1
</value><value>
</value><value>result</value><value>
</value><value>

</value></text><lastUpdated>2020-09-28 16:51</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/p/13772670.html</url><title>数据采集与融合技术第二次作业 - 氧化氟碳 - 博客园</title><text><value>
    </value><value>
</value><value>
</value><value>
</value><value>这个作业属于哪个课程</value><value>
</value><value>数据采集与融合技术2020</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>这个作业要求在哪里</value><value>
</value><value>第二次作业</value><value>
</value><value>
</value><value>
</value><value>学号</value><value>
</value><value>031804103</value><value>
</value><value>
</value><value>
</value><value>
</value><value>第一题</value><value>
</value><value>要求</value><value>
</value><value>在</value><value>中国气象网</value><value>给定城市集的7日天气预报，并保存在数据库。</value><value>
</value><value>思路</value><value>
</value><value>
</value><value>解析网站源码与架构</value><value>
</value><value>用BeautifulSoup解析出所需的信息</value><value>
</value><value>将数据保存在数据库（SQLite）</value><value>
</value><value>
</value><value>code</value><value>
</value><value>from bs4 import BeautifulSoup
from bs4 import UnicodeDammit
import urllib.request
import sqlite3

class WeatherDB: ##database

    def openDB(self):
        self.con=sqlite3.connect("weathers.db")
        self.cursor=self.con.cursor()
        try:
            self.cursor.execute("create table weathers (wCity varchar(16),wDate varchar(16),wWeather varchar(64),wTemp varchar(32),constraint pk_weather primary key (wCity,wDate))")
        except:
            self.cursor.execute("delete from weathers")

    def closeDB(self):
        self.con.commit()
        self.con.close()

    def insert(self,city,date,weather,temp):
        try:
            self.cursor.execute("insert into weathers (wCity,wDate,wWeather,wTemp) values (?,?,?,?)" ,(city,date,weather,temp))
        except Exception as err:
            print(err)

    def show(self):
        self.cursor.execute("select * from weathers")
        rows=self.cursor.fetchall()
        print("%-16s%-16s%-32s%-16s" % ("city","date","weather","temp"))
        for row in rows:
            print("%-16s%-16s%-32s%-16s" % (row[0],row[1],row[2],row[3]))

class WeatherForecast:
    def __init__(self):
        self.headers = {
            "User-Agent": "Mozilla/5.0 (Windows; U; Windows NT 6.0 x64; en-US; rv:1.9pre) Gecko/2008072421 Minefield/3.0.2pre"}
        self.cityCode={"北京":"101010100","上海":"101020100","广州":"101280101"} #城市编码

    def forecastCity(self,city):
        if city not in self.cityCode.keys():
            print(city+" code cannot be found")
            return
        url="http://www.weather.com.cn/weather/"+self.cityCode[city]+".shtml"
        try:
            req=urllib.request.Request(url,headers=self.headers)
            data=urllib.request.urlopen(req)
            data=data.read()
            dammit=UnicodeDammit(data,["utf-8","gbk"])
            data=dammit.unicode_markup
            soup=BeautifulSoup(data,"lxml")
            lis=soup.select("ul[class='t clearfix'] li")
            for li in lis:
                try:
                    date=li.select('h1')[0].text
                    weather=li.select('p[class="wea"]')[0].text
                    temp=li.select('p[class="tem"] span')[0].text+"/"+li.select('p[class="tem"] i')[0].text
                    print(city,date,weather,temp)
                    self.db.insert(city,date,weather,temp)
                except Exception as err:
                    print(err)
        except Exception as err:
            print(err)

    def process(self,cities): ##传进城市列表
        self.db=WeatherDB()
        self.db.openDB()

        for city in cities:
            self.forecastCity(city)

        #self.db.show()
        self.db.closeDB()

ws=WeatherForecast()
ws.process(["北京","上海","广州"])
# print("completed")
</value><value>
</value><value>运行结果</value><value>
</value><value>
</value><value>心得体会</value><value>
</value><value>第一次用与CSS有关的爬取解析、选择所需要的数据，而不再局限于HTML</value><value>
</value><value>第二题</value><value>
</value><value>要求</value><value>
</value><value>用requests和BeautifulSoup库方法定向爬取股票相关信息。</value><value>
候选网站：</value><value>东方财富网</value><value>、​</value><value>新浪股票</value><value>
</value><value>思路</value><value>
</value><value>
</value><value>选择东方财富网</value><value>
</value><value>网页的HTML不能直接得到所需数据，而且数据是不断更新的</value><value>
</value><value>考虑截获页面的请求数据，即刷新网站时向服务器发起的JSON文件请求</value><value>
</value><value>查找以后发现JSON文件请求大概是这样开头的URL：</value><value>http://97.push2.eastmoney.com/api/qt/clist/get?cb=jQueryxxxxxxxxxxxx......</value><value>
</value><value>翻页只需要改变json请求URL中的一个数值即可实现，为了减轻PC压力，只爬取前五页的数据</value><value>
</value><value>得到JSON后用正则表达式匹配得到数据</value><value>
</value><value>
</value><value>code</value><value>
</value><value>import re
import requests

url_head = 'http://97.push2.eastmoney.com/api/qt/clist/get?cb=jQuery112406971740416068926_1601446076156&amp;pn='
url_tail = '&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;fid=f3&amp;fs=m:0+t:6,m:0+t:13,m:0+t:80,m:1+t:2,m:1+t:23&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f22,f11,f62,f128,f136,f115,f152&amp;_=1601446076157'

def get_stock(url,count):
    json_page = requests.get(url).content.decode(encoding='utf-8')
    # json_page = json_page.read()
    pat = "\"diff\":\[\{.*\}\]"
    table = re.compile(pat,re.S).findall(json_page)
    pat = "\},\{"
    stocks = re.split(pat,table[0])
    # count = 1
    for stock in stocks:
        # print(stock)
        pat = ","
        infs = re.split(pat,stock)
        # print(infs[13])
        pat = ":"
        name = re.split(pat,infs[13])
        money = re.split(pat,infs[1])
        num = re.split(pat,infs[11])
        Quote_change = re.split(pat,infs[2])  # 涨跌幅
        Ups_and_downs = re.split(pat,infs[3])  # 涨跌额
        Volume = re.split(pat,infs[4])  #成交量
        Turnover = re.split(pat,infs[5])  #成交额
        Increase = re.split(pat,infs[6])  #涨幅
        # print(count,num[1],name[1],money[1],Quote_change[1]+"%",Ups_and_downs[1]+"￥",str(Volume[1])+"手",Turnover[1]+"￥",Increase[1]+"%")
        print('%-8s %-10s %-10s %10s %10s %15s %15s %18s %12s'%(count,num[1],name[1],money[1],Quote_change[1],Ups_and_downs[1],Volume[1],Turnover[1],Increase[1]))
        count += 1
    return count

print('%-8s %-6s %-8s %10s %10s %12s %10s %10s %12s'%('序号','代码','名称','最新价','涨跌幅(%)','跌涨额(￥)','成交量(手)','成交额(￥)','涨幅(%)'))
count = 1
for i in range(1,6):
    count = get_stock(url_head+str(i)+url_tail,count)
</value><value>
</value><value>运行结果</value><value>
</value><value>
</value><value>心得体会</value><value>
</value><value>第一次遇到需要查找页面向服务器发起请求url才能得到数据的情况,强化了自己使用正则表达式的熟练程度</value><value>
</value><value>第三题</value><value>
</value><value>要求</value><value>
</value><value>根据自选3位数+学号后3位选取股票，获取印股票信息。抓包方法同作问题二</value><value>
</value><value>思路</value><value>
</value><value>
</value><value>学号结尾是103,搜了一下能匹配的并不多,故选择了</value><value>横店影视(603103)</value><value>
</value><value>与第二题的解析思路差不多,只是所需要的信息位置比较难找</value><value>
</value><value>
</value><value>code</value><value>
</value><value>import re
import requests
url = 'http://push2.eastmoney.com/api/qt/stock/get?ut=fa5fd1943c7b386f172d6893dbfba10b&amp;invt=2&amp;fltt=2&amp;fields=f43,f57,f58,f169,f170,f46,f44,f51,f168,f47,f164,f163,f116,f60,f45,f52,f50,f48,f167,f117,f71,f161,f49,f530,f135,f136,f137,f138,f139,f141,f142,f144,f145,f147,f148,f140,f143,f146,f149,f55,f62,f162,f92,f173,f104,f105,f84,f85,f183,f184,f185,f186,f187,f188,f189,f190,f191,f192,f107,f111,f86,f177,f78,f110,f262,f263,f264,f267,f268,f250,f251,f252,f253,f254,f255,f256,f257,f258,f266,f269,f270,f271,f273,f274,f275,f127,f199,f128,f193,f196,f194,f195,f197,f80,f280,f281,f282,f284,f285,f286,f287,f292&amp;secid=1.603103&amp;cb=jQuery112409262947646562985_1601451983153&amp;_=1601451983154'
json_page = requests.get(url).content.decode(encoding='utf-8')
pat = "\"data\":{.*}"
table = re.compile(pat,re.S).findall(json_page)
pat = ","
infs = re.split(pat,table[0])
pat = ':'
print("代码:"+str(re.split(pat,infs[11])[1]))
print("名称:"+str(re.split(pat,infs[12])[1]))
print("今开:"+str(re.split(pat,infs[3])[1]))
print("最高:"+str(re.split(pat,infs[1])[1]))
print("涨停:"+str(re.split(pat,infs[8])[1]))
print("换手:"+str(re.split(pat,infs[54])[1]+"%"))
print("成交量:"+str(re.split(pat,infs[4])[1]+"万手"))
</value><value>
</value><value>运行结果</value><value>
</value><value>
</value><value>心得体会</value><value>
</value><value>单个页面的请求相对更加难找信息,因为涉及到的requests太多,寻找JSON对应的URL也花了一些时间,但总体上和第二题没有太大区别.</value><value>

</value></text><lastUpdated>2020-10-08 00:26</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/archive/2020/10/11.html</url><title>2020 年 10月 11 日 随笔档案 - 氧化氟碳 - 博客园</title><text></text><lastUpdated>None</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/archive/2019/01/26.html</url><title>2019 年 1月 26 日 随笔档案 - 氧化氟碳 - 博客园</title><text></text><lastUpdated>None</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/archive/2019/01/31.html</url><title>2019 年 1月 31 日 随笔档案 - 氧化氟碳 - 博客园</title><text></text><lastUpdated>None</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/p/10393098.html</url><title>2019寒假训练营第三次作业part1-网络空间安全概论第五章 - 氧化氟碳 - 博客园</title><text><value>
    </value><value>第五章 网络攻防技术</value><value>
</value><value>5.1 网路信息收集技术--网络踩点</value><value>
</value><value>
</value><value>黑客入侵系统之前，需要了解目标系统可能存在的：
</value><value>
</value><value>管理上的安全缺陷和漏洞</value><value>
</value><value>网络协议安全缺陷与漏洞</value><value>
</value><value>系统安全缺陷与漏洞</value><value>
</value><value>
</value><value>
</value><value>黑客实施入侵过程中，需要掌握：
</value><value>
</value><value>目标网络的内部拓扑结构</value><value>
</value><value>目标系统与外部网络的连接方式与链路路径</value><value>
</value><value>防火墙的端口过滤与访问控制配置</value><value>
</value><value>使用的身份认证与访问控制机制</value><value>
</value><value>
</value><value>
</value><value>网络踩点：
</value><value>
</value><value>通过有计划的信息收集，了解攻击目标的隐私信息、网络环境和信息安全状况</value><value>
</value><value>根据踩点结果，攻击者寻找出攻击目标可能存在的薄弱环节，为进一步的攻击提供指引</value><value>
</value><value>
</value><value>
</value><value>网络踩点常用手段
</value><value>
</value><value>Google Hacking
</value><value>
</value><value>
</value><value>通过网络搜索引擎查找特点安全漏洞或是私密信息</value><value>
</value><value>
</value><value>
</value><value>常用的搜索引擎：</value><value>
</value><value>
</value><value>www.ZoomEye.org</value><value>
</value><value>www.google.com</value><value>
</value><value>www.altavista.com</value><value>
</value><value>www.dogpile.com</value><value>
</value><value>
</value><value>
</value><value>
</value><value>Google Hacking客户端软件：Athena,Wikto,SiteDigger</value><value>
</value><value>
</value><value>
</value><value>能否利用搜索引擎在WEB中找到所需信息，关键在于能否合理提取搜索关键字</value><value>
</value><value>
</value><value>
</value><value>
</value><value>防范Google Hacking</value><value>
</value><value>
</value><value>将敏感信息从公共媒体上删除</value><value>
</value><value>发现存在非预期泄露的敏感信息后，应采取行动进行清楚</value><value>
</value><value>发表信息时，尽量不要出现真实个人信息</value><value>
</value><value>做为网络管理者，不要轻易在讨论组或技术论坛发布求助技术贴，防止将单位内部网络拓扑结构或路由器配置泄露给他人</value><value>
</value><value>关注中国国家漏洞库CNNVD等安全漏洞信息库发布的技术信息，及时更新软件或操作系统补丁</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>WhoIs查询
</value><value>
</value><value>DNS注册信息WhoIs查询：查询特定域名的3R详细注册信息
</value><value>
</value><value>3R:
</value><value>
</value><value>已注册域名的注册人（Registrant）信息，包括域名登记人信息、联系方式、域名注册时间和更新时间、权威DNS IP地址等。</value><value>
</value><value>注册商（Registrar）信息</value><value>
</value><value>官方注册局（Registry）信息</value><value>
</value><value>
</value><value>
</value><value>官方注册局一般会提供注册商和Referral URL信息，具体注册信息则位于注册商数据库中</value><value>
</value><value>DNS WhoIs查询思路
</value><value>
</value><value>ICANN：因特网技术协调机构，负责协调以下因特网标识符的分配工作：
</value><value>
</value><value>域名、IP地址、网络通信协议的参数指标和端口号</value><value>
</value><value>位于DNS/IP层次化管理结构的顶层，因此是手动WHOIS查询的最佳入口点</value><value>
</value><value>
</value><value>
</value><value>一般思路
</value><value>
</value><value>在www.iana.org 得到某个提供whois查询服务的机构</value><value>
</value><value>进一步查询域名注册商</value><value>
</value><value>在域名注册商上查询注册信息</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>IP WhoIs查询：查询特定的IP地址的详细注册信息
</value><value>
</value><value>ICANN的地址管理组织ASO总体负责IP地址分配工作</value><value>
</value><value>具体IP网段分配记录和注册者信息都储存于各个洲际互联网管理局RIR的数据库中</value><value>
</value><value>有时需要到国家/地区互联网注册局NIR（中国为CNNIC）或ISP查询更细致信息</value><value>
</value><value>查询过程
</value><value>
</value><value>ARIN的Whois Web服务，告知这段IP由AONIC管辖</value><value>
</value><value>APNIC的Whois Web服务，给出该网段其他详细信息</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>whois查询安全防范
</value><value>
</value><value>及时更新管理性事务联系人的信息</value><value>
</value><value>尝试使用虚拟的人名来作为管理性事务联系人</value><value>
</value><value>使用域名注册商提供的私密注册服务，确保敏感信息不被公开</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>DNS查询
</value><value>
</value><value>DNS：一个提供域名到IP地址的映射或者将IP地址映射成域名的分布式数据库系统</value><value>
</value><value>DNS区域传送：
</value><value>
</value><value>辅助DNS服务器使用来自主服务器的数据刷新自己的ZONE数据库</value><value>
</value><value>为运行中的DNS服务提供一定的冗余度，防止因主服务器故障而导致域名解析器服务不可用</value><value>
</value><value>DNS区域传送一般仅限于辅助DNS服务器才能向主服务器发起请求</value><value>
</value><value>
</value><value>
</value><value>DNS服务：允许不受信任的因特网用户执行DNS区域传送请求，是严重的配置错误
</value><value>
</value><value>在错误配置时DNS服务器会接受任何一个主机的DNS区域传送请求</value><value>
</value><value>如果没有使用公用/私用DNS机制分割外部公用DNS信息和内部私用DNS信息，任何攻击者都可以得到机构的所有内部主机和IP地址</value><value>
</value><value>
</value><value>
</value><value>解决方案：对外的DNS服务器配置为禁止DNS区域传送，且该服务器不能包含内部网络相关主机的敏感信息</value><value>
5.2网路信息收集技术--网络扫描</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>网络扫描：攻击者通过扫描技术找到目标可能的入侵漏洞</value><value>
</value><value>
</value><value>
</value><value>类型</value><value>
</value><value>
</value><value>
</value><value>主机扫描：向目标系统发出特定的数据包，并分析目标系统返回的相应结果的行为
</value><value>
</value><value>使用ICMP协议</value><value>
</value><value>常见扫描技术
</value><value>
</value><value>ICMP Ping扫描</value><value>
</value><value>端口扫描</value><value>
</value><value>
</value><value>
</value><value>防范
</value><value>
</value><value>使用例如Snort入侵扫描检测系统，或者McAfee桌面防火墙工具，来检测主机扫描活动</value><value>
</value><value>根据业务要求，仔细考虑允许哪些类型的ICMP通信进入网络
</value><value>
</value><value>使用访问控制列表机制ACL</value><value>
</value><value>只允许制定的ICMP数据包到达特定主机</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>端口扫描：攻击者通过连接到目标系统的TCP/UDP端口，已确定有哪些服务正处于监听状态
</value><value>
</value><value>常见端口扫描技术
</value><value>
</value><value>TCP端口扫描</value><value>
</value><value>TCP SYN扫描</value><value>
</value><value>TCP FIN扫描</value><value>
</value><value>TCP圣诞树扫描</value><value>
</value><value>TCP空扫描</value><value>
</value><value>TCP ACK扫描</value><value>
</value><value>TCP窗口扫描</value><value>
</value><value>TCP RPC扫描</value><value>
</value><value>UDP扫描</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>防范措施
</value><value>
</value><value>端口扫描监测
</value><value>
</value><value>网络入侵系统如Snort</value><value>
</value><value>
</value><value>
</value><value>端口扫描的预防
</value><value>
</value><value>开启防火墙</value><value>
</value><value>禁用所有不必要的服务</value><value>
</value><value>类UNIX:/etc/inetd.conf文件中注释掉不必要的服务，修改系统、使用脚本，禁用此类服务</value><value>
</value><value>win32：在“控制面板/服务”中关闭服务</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>操作系统/网络服务辨识
</value><value>
</value><value>操作系统类型探测技术：TCP/IP协议栈指纹分析
</value><value>
</value><value>不同的操作系统在实现TCP/IP协议栈时都存在着差异</value><value>
</value><value>RFC中没有对TCP/IP协议实现给予精确的定义</value><value>
</value><value>不同的操作系统产生商，在实现TCP/IP协议栈时，也没有完全按照RFC所定义的标准来实现</value><value>
</value><value>
</value><value>
</value><value>不同的网络服务在实现应用层协议时也存在差异</value><value>
</value><value>防范措施
</value><value>
</value><value>使用端口扫描检测工具，发现对操作系统的探查活动</value><value>
</value><value>部署安全的防火墙以保护目标主机</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>漏洞扫描
</value><value>
</value><value>安全漏洞：通常指硬件、软件或策略上存在的安全缺陷，利用这些安全缺陷，攻击者能够在未授权的情况下访问、控制、甚至破坏目标系统</value><value>
</value><value>目的：探测目标网络的特定操作系统、网络服务、应用程序中是否存在已公布安全漏洞</value><value>
</value><value>防范措施
</value><value>
</value><value>在黑客之前扫描漏洞</value><value>
</value><value>补丁自动更新和分发，修补漏洞</value><value>
</value><value>保证所安装软件的来源安全</value><value>
</value><value>开启操作系统和应用软件的自动更新机制</value><value>
5.3网路信息收集技术--网络查点</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>查点：对选择好的攻击目标，发起主动的连接和查询，针对性的收集发起实际攻击所需的具体信息内容</value><value>
</value><value>网络服务旗标抓取：利用客户端工具连接至远程网络服务并观察输出以搜集关键信息的技术手段
</value><value>
</value><value>通用网络服务查点
</value><value>
</value><value>通用网络服务</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>Windows平台网络服务查点：利用Windows平台特有的网络服务协议
</value><value>
</value><value>NETBIOS名字服务查询</value><value>
</value><value>SMB会话查询</value><value>
</value><value>目录查询</value><value>
</value><value>MSRPC查点</value><value>
</value><value>防范措施：
</value><value>
</value><value>关闭不必要的服务及窗口</value><value>
</value><value>关闭打印与共享服务（SMB）</value><value>
</value><value>不要让主机名暴露使用者身份</value><value>
</value><value>关闭不必要共享，特别是可写共享</value><value>
</value><value>关闭默认共享限制IPC$默认共享的匿名空连接等</value><value>
5.4Windows系统渗透基础</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>控制注入攻击：</value><value>
</value><value>
</value><value>现代计算机系统遵循冯诺依曼体系结构，没有在内存中严格区分计算机程序的数据和指令，使得程序外部的指令数据有可能被当作指令代码执行。</value><value>
</value><value>攻击者目标：劫持应用程序控制流来执行目标系统上的任意代码，最终达到远程控制目标系统的目的</value><value>
</value><value>劫持攻击技术：
</value><value>
</value><value>缓冲区溢出：
</value><value>
</value><value>栈溢出
</value><value>
</value><value>利用方式：符改函数返回地址</value><value>
</value><value>
</value><value>
</value><value>堆溢出</value><value>
</value><value>
</value><value>
</value><value>格式化字符串漏洞</value><value>
</value><value>整数溢出</value><value>
</value><value>指针释放后再次被使用</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>Windows系统主要的网络服务程序：</value><value>
</value><value>
</value><value>NetBIOS网络服务</value><value>
</value><value>SMB网络服务</value><value>
</value><value>MSRPC网络服务</value><value>
</value><value>RDP远程桌面服务</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>远程渗透Windows系统的途径</value><value>
</value><value>
</value><value>缓冲区溢出攻击</value><value>
</value><value>认证欺骗</value><value>
</value><value>客户端软件漏洞利用</value><value>
</value><value>设备驱动漏洞利用</value><value>
</value><value>
</value><value>
</value><value>
</value><value>针对系统渗透攻击的常见防范措施</value><value>
</value><value>
</value><value>及时更新应用软件、操作系统、硬件设备驱动程序的安全补丁</value><value>
</value><value>禁用不必要的网络服务</value><value>
</value><value>使用防火墙来限制可能存在漏洞的服务的访问</value><value>
</value><value>强制用户使用强口令，并定期更换口令</value><value>
</value><value>审计与日治</value><value>
</value><value>使用扫描软件主动发现系统是否存在已知安全漏洞，安装入侵检测/防御系统</value><value>
</value><value>客户端应用程序尽量使用受限权限，而非管理员或同等级权限的用户登录因特网</value><value>
</value><value>运行并及时更新防病毒软件</value><value>
</value><value>禁用以受攻击的硬件设备</value><value>
5.5Internet协议安全问题</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>终端设备、路由器以及其他因特网连接设备，都要运行一系列协议，这些协议控制因特网中信息的接受和发送，因特网的主要协议成为TCP/IP协议</value><value>
</value><value>
</value><value>
</value><value>网络安全五大属性（CIA)</value><value>
</value><value>
</value><value>机密性</value><value>
</value><value>完整性</value><value>
</value><value>可用性</value><value>
</value><value>真实性</value><value>
</value><value>不可抵赖性</value><value>
</value><value>
</value><value>
</value><value>
</value><value>网络攻击基本模式</value><value>
</value><value>
</value><value>被动威胁
</value><value>
</value><value>截获（窃听）（破坏机密性）
</value><value>
</value><value>嗅探</value><value>
</value><value>监听</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>主动威胁
</value><value>
</value><value>篡改（破坏完整性）
</value><value>
</value><value>数据包篡改</value><value>
</value><value>
</value><value>
</value><value>中断（破坏可用性）
</value><value>
</value><value>拒绝服务</value><value>
</value><value>
</value><value>
</value><value>伪造（破坏真实性）
</value><value>
</value><value>欺骗</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>因特网协议栈层次结构</value><value>
</value><value>
</value><value>
</value><value>网络层基础协议：IP协议、ARP地址协议解析协议、BGP边界网关协议等动态路由协议</value><value>
</value><value>
</value><value>IP源地址欺骗攻击：路由器只根据目标IP地址进行路由转发，不对源IP地址做验证，常被利用于发起匿名Dos攻击</value><value>
</value><value>
</value><value>
</value><value>
</value><value>传输层协议：UDP和TCP协议</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>基于TCP协议安全缺陷引发的TCP RST攻击（伪造TCP重置报文攻击）</value><value>
</value><value>
</value><value>
</value><value>
</value><value>TCP会话劫持攻击</value><value>
</value><value>
</value><value>
</value><value>
</value><value>应用层协议：目前流行的应用层协议如HTTP、FTP、SMTP/POP3、DNS等均缺乏合理的身份验证机制，加上大多采用铭文传输通信数据，因此普遍存在被嗅探、欺骗、中间人攻击等风险。</value><value>
</value><value>
</value><value>DNS协议</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>    - 拒绝式服务攻击（DoS）：用超出目标处理能力的海量数据包消耗可用系统资源、宽带资源等，或造成程序缓冲区溢出错误，导致其无法处理合法用户的正常请求，最终致使网络服务瘫痪，甚至系统死机。
        - 弱点攻击
        - 洪泛攻击
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>TCP/IP网络协议栈攻击防范措施
</value><value>
</value><value>网络接口层，检测和防御网络威胁，对网关路由器等关键网络节点设备进行安全防护，优化网络结构，增强链路层加密强度</value><value>
</value><value>网络层，采用多种过滤和检测技术来发现和阻断网络中欺骗攻击，增强防火墙、路由器和网关设备的安全策略，关键服务器使用静态绑定IP-MAC映射表、使用IPsec协议加密通讯等预防机制</value><value>
</value><value>传输层加密传输和安全控制机制，包括身份认证和访问</value><value>
</value><value>应用层加密，用户级身份认证，数字签名技术，授权和访问控制技术以及审计、入侵检测</value><value>
</value><value>
</value><value>
</value><value>
</value><value>5.6基本的web安全</value><value>
</value><value>
</value><value>跨站脚本攻击（XSS)：攻击者利用网页开发时留下的漏洞，通过巧妙的方式注入恶意代码到网页，使用户加载网页时会运行攻击者恶意制造的代码，脚本可以是JavaScript、VBSvript、ActiveX、Flash、HTML。攻击成功后，攻击者会得到敏感信息，以获取更高用户权限，以被攻击者身份执行操作
</value><value>
</value><value>反射型XSS</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>- 储存型XSS
- DOM-XSS
</value><value>
</value><value>
</value><value>- 防范XSS攻击
    - 在浏览器设置中关闭JavaScript，关闭cookie或设置为为只读，提高浏览器的安全等级设置，尽量使用非IE的安全浏览器来降低风险
    - 只信任值得信任的站点或内容，不要轻易点击不明链接
</value><value>
</value><value>
</value><value>SQL注入：利用web应用程序输入验证不完善的漏洞，将一段精心构造的SQL命令注入到后台数据库引擎执行
</value><value>
</value><value>
</value><value>SQL注入的危害</value><value>
</value><value>
</value><value>数据库中的用户隐私信息被泄露</value><value>
</value><value>对特定网页进行篡改</value><value>
</value><value>通过修改数据库一些字段的值，嵌入木马链接，进行挂马攻击</value><value>
</value><value>数据库的系统管理员账户被修改</value><value>
</value><value>服务器被黑客安装后门进行远程控制</value><value>
</value><value>破坏硬盘数据，瘫痪全系统</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>SQL注入的主要原因是web应用程序没有对用户输入进行严格的转义字符过滤和类型检查</value><value>
</value><value>
</value><value>防范：
</value><value>
</value><value>使用类型安全的参数编码机制</value><value>
</value><value>对来自程序外部的用户输入，必须进行完备检查</value><value>
</value><value>将动态SQL语句替换为存储过程，预编译SQL或ADO命令对象</value><value>
</value><value>加强SQL数据库服务器的配置与连接，以最小权限配置原则配置web应用程序连接数据库的操作权限，避免将敏感数据明文存放于数据库中</value><value>
</value><value>跨站请求伪造（CSRF)</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>csrf实际上是利用了web身份验证的漏洞：基于cookies的身份验证只能保证请求发自用户的浏览器，却不能保证请求时用户自愿发出的</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>- 对CSRF攻击的防御
    - 服务端
    - 客户端
    - 设备端
- 预防措施
    - 不要点击未知的链接或图片
    - 及时退出已登录账户
    - 为计算机系统安装安全防护软件，及时更新特征库和软件升级
    - 安装浏览器插件扩展防护
</value><value>
</value><value>5.7社会工程学攻击</value><value>
</value><value>
</value><value>攻击形式
</value><value>
</value><value>信息收集</value><value>
</value><value>心理诱导</value><value>
</value><value>身份伪造</value><value>
</value><value>施加影响</value><value>
</value><value>
</value><value>
</value><value>希望获得的信息
</value><value>
</value><value>可能直接导致攻击对象的财产或身份被盗</value><value>
</value><value>能力也这些信息获取目标组织的薄弱环节</value><value>
</value><value>向攻击目标发动更有针对性的攻击</value><value>
</value><value>
</value><value>
</value><value>防范
</value><value>
</value><value>了解熟悉社会工程学诈骗</value><value>
</value><value>对自己的基础信息保持足够的警惕不要通过不安全的方式透露个人、家庭、公司一些看似无关紧要的信息</value><value>
</value><value>涉及敏感信息，务必核实对方身份使用防火墙保护个人电脑，同时提高垃圾邮件过滤器的门槛!</value><value>
</value><value>
</value><value>
</value><value>

</value></text><lastUpdated>2019-02-17 23:17</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/p/10344384.html</url><title>寒假训练营第二次作业 - 氧化氟碳 - 博客园</title><text><value>
    </value><value>2019寒假训练营第二次作业</value><value>
</value><value>一、学习视频课程：网络空间安全概论</value><value>
</value><value>第一章：网络空间安全概述</value><value>
</value><value>1.1绪论</value><value>
</value><value>我国网络空间安全面临严峻考验</value><value>
网络空间安全包括人、机、物以及其中产生、处理、传输、存储的各种信息数据的安全</value><value>
</value><value>1.2网络框架安全威胁</value><value>
</value><value>
</value><value>网络空间安全框架</value><value>
</value><value>设备层威胁：
</value><value>
</value><value>皮下植入RFID芯片，以触摸的形式入侵设备，窃取隐私信息。</value><value>
</value><value>通过分析计算机辐射电磁波，分析得到隐私数据（设备不联网不代表绝对安全）。</value><value>
</value><value>伊朗核电站虽然处在信息系统物理隔绝中，仍然遭到病毒袭击。</value><value>
</value><value>硬件木马：恶意电路，多出现于军事领域（不同与软件木马）</value><value>
</value><value>
</value><value>
</value><value>系统层威胁
</value><value>
</value><value>SQL注入：把SQL命令插入到web表单提交或输入域名或页面请求的查询字符串，以欺骗服务器，引起信息泄露。</value><value>
</value><value>恶意代码：特洛伊木马、计算机病毒</value><value>
</value><value>数据层威胁</value><value>
</value><value>免费WiFi</value><value>
</value><value>智能设备</value><value>
</value><value>蓝牙协议漏洞</value><value>
</value><value>
</value><value>
</value><value>应用层威胁
</value><value>
</value><value>群发短信中内含危险网站，其域名与一些官网很相似。</value><value>
</value><value>利用充电桩窃取数据</value><value>
</value><value>
</value><value>
</value><value>
</value><value>1.3网络空间安全框架</value><value>
</value><value>
</value><value>
</value><value>网络空间安全包括许多基础维度：</value><value>
设备安全、网络安全、应用安全、大数据安全、舆情分析、隐私保护、密码学及其应用、网络空间安全实战、网络空间安全治理等。</value><value>
</value><value>
</value><value>网络空间安全框架
</value><value>
</value><value>设备层安全：物理、环境、设备安全</value><value>
</value><value>系统层安全：网络、计算机、软件、操作系统、数据库安全</value><value>
</value><value>数据层安全：数据、身份、隐私安全</value><value>
</value><value>应用层安全：内容、支付、控制、物联网、应用安全</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>网络空间安全需求</value><value>
</value><value>
</value><value>互联网治理问题：信息对抗、舆论安全、网络攻防体系建设</value><value>
</value><value>移动互联网安全、可信计算、云计算安全、大数据安全、物联网安全、广电网安全</value><value>
</value><value>特定安全保障：在线社交网络、工业控制安全、支付安全</value><value>
</value><value>
</value><value>
</value><value>
</value><value>网络空间安全问题</value><value>
</value><value>
</value><value>
</value><value>网络空间安全模型：基于闭环控制的动态信息安全理论模型（P2DR2）</value><value>
</value><value>
</value><value>
</value><value>
</value><value>第四章：网络安全技术</value><value>
</value><value>4.1防火墙（firewall）概述</value><value>
</value><value>
</value><value>防火墙是网络安全防御系统，根据安全规则，对相应的网络数据流进行监视和控制。
</value><value>
</value><value>网络防火墙</value><value>
外部网络（不可信任网络）和本地网络（可信任网络）之间的所有数据流都需要经过网络防火墙的处理，拦截异常数据流。</value><value>
</value><value>主机防火墙</value><value>
</value><value>防火墙的作用
</value><value>
</value><value>安全域划分与安全域策略部署：将安全需求相同的接口或IP地址划分到相同的域，实现策略的分层管理，将网络划分为：不可信区域，可信区域，DMZ区域</value><value>
</value><value>根据访问控制列表实现访问控制</value><value>
</value><value>防止内部信息外泄：屏蔽泄露内部细节服务的信息，将内部网络结构隐藏起来。</value><value>
</value><value>审计功能：审查网络连接记录、历史记录、故障记录</value><value>
</value><value>部署网络地址转换：缓解地址短缺问题，隐藏地址网络信息。</value><value>
</value><value>
</value><value>
</value><value>防火墙的局限性
</value><value>
</value><value>无法防范来自网络内部的恶意攻击</value><value>
</value><value>无法防范不经过防火墙的攻击</value><value>
</value><value>防火墙会带来传输的延迟、通信瓶颈和单点失效等问题</value><value>
</value><value>防火墙无法阻止对服务器合法开发的端口</value><value>
</value><value>防火墙本身存在漏洞而遭到攻击</value><value>
</value><value>防火墙不能处理病毒和木马攻击</value><value>
</value><value>限制了存在安全缺陷的网络服务，影响了用户使用服务的便利性</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>4.2防火墙关键技术</value><value>
</value><value>- 数据包过滤技术：检查网络中每个通过对数据包，根据访问控制列表的通行规则，决定对一个数据包的放行、丢弃。
    - 在防火墙中检查数据包基本信息：IP地址、数据包协议类型、端口号、进出的网络接口，与预期的访问控制列表进行对比。
    - 优点：对用户透明、通过路由器实现、处理速度快
    - 缺点：规则表的制定复杂、核查简单、以单个数据包为处理单位
- 应用层代理技术：作用在应用层，用来提供应用层服务的控制，在内部网络向外部网络申请服务时起到中间转接作用
     - 优点：不允许外部主机直接访问内部主机，将内外完全隔离，比较安全；可以提供多种用户认证方案；可以分析数据包内部的应用命令；可以提供详细的审计记录
    - 缺点：
        - 对于每一种应用服务都必须为其设计一个代理软件模块来进行安全控制，而每一种网络应用服务的安全问题各不相同，分析困难，因此实现也困难。对于新开发的应用，无法通过相应的应用代理。
        - 由于检查整个应用报文内容，存在延迟问题
- 状态检测技术：采用一种基于连接的状态检测机制，将属于同一个连接的所有包作为一个整体的数据流来看待，建立连接状态表，并进行维护通过规则表和状态表的共同配合，动态地决定数据包是否被允许进入防火墙内部网络。应用于网络层、传输层、应用层，跟踪通过防火墙的网络连接和数据包，并使用一组状态检测标准，已确定是否允许或拒绝通信
    - 优点：具备较快的处理速度和灵活性；具备理解应用程序状态的能力和高度安全性；减小了伪造数据包通过防火墙的可能性
    - 缺点：记录状态信息，会导致网络迟滞；跟踪各类协议，技术较为复杂
- 网络地址转换技术：最初用来解决私有IP地址的上网问题
    - 转换方式：
        - 多对1映射：多个内部网络地址翻译到一个IP地址，来自内部不同的连接请求可以用不同的端口号来区分（常用于普通家庭）
        - 1对1映射：网关将内部网络上的每台计算机映射到NAT的合法地址集中唯一的一个IP地址（常用于Web服务器）
        - 多对多映射：将大量的不可路由的内部IP地址转换为少数合法IP地址，可以隐藏内部IP地址分为静态翻译、动态翻译
    - 优点：对外隐藏内部网络主机地址；实现网络的负载均衡；缓解互联网IP地址的不足问题 
-  个人防火墙技术：安装在本地计算机上的系统安全软件，可以监视传入传出网卡的所有网络通信，使用状态检测技术，保护一台计算机免受攻击
    - 优点：增加了保护级别，不需要额外的硬件资源，通常是免费的软件资源
    - 缺点个人防火墙自身受到攻击，可能会失效，而将主机暴露在网络上
</value><value>
</value><value>4.3入侵检测技术IDS：</value><value>
</value><value>一种主动的安全防护技术，以旁路方式接入网络，通过实时监测计算机网络和系统，来发现违反安全策略访问的过程。继防火墙之后的第二道防线，在不影响网络性能的前提下，通过实时收集和分析计算机网络或系统的审计信息，来检测是否出现违反安全策略的行为和攻击的痕迹，达到防止攻击和预防攻击的目的。是对防火墙的有益补充，可以在网络系统中快速发现已知或未知的网络攻击行为，扩展了系统管理员的安全管理能力，提高安全系统的完整性。
- 作用和优势
    - 能快速检测入侵行为
    - 能形成网络入侵的威慑力，防护入侵者的作用
    - 收集入侵信息，增强入侵防护系统的防护能力
- 主要功能
    - 监控、分析用户和系统的活动
    - 发现入侵企图和异常现象
    - 审计系统的配置和漏洞
    - 评估关键系统和数据文件的完整性
    - 对异常活动的统计分析
    - 识别攻击的活动模型
    - 实时报警与主动响应
- 入侵检测通用模型
</value><value>
</value><value>
</value><value>    - 事件产生器：负责原始数据采集，对数据流、日志文件进行追踪，将原始数据转换为事件，并提供给其他组件。
    - 事件分析器：接收事件信息，并采用检测方法进行分析，判断是否入侵行为或者异常现象，将分析结果转换为警告信息。
    - 相应单元：根据警告信息做出反应，以阻止入侵。
    - 事件数据库：从事件产生器和事件分析器接收数据，存放各种中间或者最终数据。
-分类：
    - 基于网络的入侵检测系统
</value><value>
</value><value>
</value><value>    - 基于主机的入侵检测系统
</value><value>
</value><value>
</value><value>    - 分布式入侵检测系统（综合前两个检测系统）
</value><value>
</value><value>
</value><value>- 入侵检测方法分类
    - 特征检测（误用检测），检测已知攻击
</value><value>
</value><value>
</value><value>    - 异常检测，检测未知攻击，用机器学习建立正常的用户使用模型，易产生误报和漏报。
</value><value>
</value><value>
</value><value>4.4虚拟专用网VPN</value><value>
</value><value>
</value><value>
</value><value>使用本地IP地址，实现机构内部主机的地址分配，无需使用全球IP地址</value><value>
</value><value>
</value><value>
</value><value>原理</value><value>
</value><value>
</value><value>
</value><value>
</value><value>远程接入VPN：流动用户访问内部网络</value><value>
</value><value>
</value><value>
</value><value>二、程序题(80'+50')</value><value>
</value><value>对于你所完成题目，把实现思路和实现结果记录在博客中，把代码提交到github的仓库上。</value><value>
</value><value>背景</value><value>
</value><value>大学期间，你总是点子很多，你利用申请的专利，开了一家互联网公司，为客户提供高效、快捷的服务。</value><value>
有一天，订单量突然大涨，欣喜之余，秘书却告诉你，今天的营业额跌到谷底，客服电话被打爆。</value><value>
你发现，看似很多的订单请求，其实只是给你发了一个“hello”而已，服务器忙于应付大量的hello， 已经没办法给原有用户提供正常的服务了，基本处于瘫痪的状态。</value><value>
经过讨论，可能是受到了黑客的DDos（分布式拒绝服务）攻击。黑客通过发送大量的无用的请求信息，占用你的服务器资源，让服务器没法给用户提供正常的服务。</value><value>
做法</value><value>
当务之急，是先恢复服务器，把攻击你的黑客都拉进黑名单，让服务器不要理会这些请求。</value><value>
第一步，就是要把黑客检测出来。</value><value>
你需要对请求进行审查，找出其中有问题的请求，然后把发送方拉黑。</value><value>
这些请求长这个样子：发送方的名字由4个小写英文字母组成，后面跟着接收方和请求信息的大小，你可以通过请求信息的大小推测请求的内容。</value><value>
发送方 接收方 请求信息的大小 发送方 接收方 请求信息的大小</value><value>
abcd bob 64 abcd bob 64</value><value>
khfd bob 265 abcd bob 64</value><value>
okng bob 364 abcd bob 64</value><value>
abcd bob 64 abcd bob 64</value><value>
abcd bob 64 abcd bob 64</value><value>
dasj bob 863 abcd bob 64</value><value>
abcd bob 64 abcd bob 64</value><value>
abcd bob 64 abcd bob 64</value><value>
abcd bob 64 abcd bob 64</value><value>
abcd bob 64 abcd bob 64</value><value>
abcd bob 64 abcd bob 64</value><value>
abcd bob 64 abcd bob 64</value><value>
abcd bob 64 abcd bob 64</value><value>
abcd bob 64 abcd bob 64</value><value>
……</value><value>
你的服务器就是那个可怜的Bob，而发送方有很多，有的是普通用户，而有的就是黑客了。</value><value>
很明显，黑客在短时间给你发了大量的信息，发送方中的 abcd 就很有可能是黑客，因为他在短时间内给你发了很多信息量很小的请求（64，很可能只有hello），而且这些请求值总值已经超过了1500。本着宁错杀一千，不放过一个的原则，只要总的请求信息的大小超过T=1500，就把它拉黑。</value><value>
描述</value><value>
编程语言不限</value><value>
</value><value>热身题(20')</value><value>
</value><value>
</value><value>学习基本的文件读写</value><value>
</value><value>读提供的文件Request.txt</value><value>
</value><value>把里面的内容写到output.txt</value><value>
</value><value>
</value><value>基本题(60')</value><value>
</value><value>
</value><value>根据提供请求的输入Request.txt，把所有请求和对应的信息大小都存下来。</value><value>
</value><value>(c语言：可以自己定义结构体，用上结构体数组，也可以用其他方法)</value><value>
</value><value>(c++:可以考虑使用stl的库里的map)</value><value>
</value><value>(推荐python:可以考虑使用字典)</value><value>
</value><value>统计每个发送方的总请求大小S，S超过T的就认定为黑客，把他们的名字存进你的黑名单里。</value><value>
-输出黑客的个数，和这些黑客的名字。</value><value>
例如：示例中有28个请求，其中abcd发了25个请求，这些请求的总和S是1600&gt;1500=T,所以abcd被认为是黑客，就把abcd加到你的黑名单里去。</value><value>
</value><value>输入：</value><value>
名字和信息大小用一个空格隔开，每条信息用一个换行隔开</value><value>
lhyy bob 100</value><value>
hzrr bob 700</value><value>
cyxx bob 364</value><value>
lhyy bob 700</value><value>
lhyy bob 800</value><value>
zzyy bob 300</value><value>
zzyy bob 800</value><value>
zzyy bob 600</value><value>
</value><value>输出：</value><value>
第一行输出黑客的总个数，第二行输出黑客名，每个黑客名用一个换行隔开</value><value>
2</value><value>
lhyy</value><value>
zzyy</value><value>
</value><value>
</value><value>基本思路：</value><value>
</value><value>
</value><value>用python的字典实现
</value><value>
</value><value>f.readlines()将文件中的文本逐行读取</value><value>
</value><value>用x = line.split(' ',2)将每一行分成三部分，储存在列表x[]中</value><value>
</value><value>将x[0]存为字典的key，x[2]存为value，对相同的key，value的值累加。</value><value>
</value><value>遍历整个字典的value，若value&gt;1500，则将对应的key存入输出文件中（value在读入，分块以后为str，要用int（）转为int类型）</value><value>
</value><value>每写入一次key，i的值加一，以便计算黑客数量</value><value>
</value><value>基本题代码地址</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>开放题(50')</value><value>
</value><value>
</value><value>
</value><value>问题一</value><value>
</value><value>
</value><value>总请求大小超过1500的不一定代表就是黑客，可能有的客户一次请求就达到了1500，从而导致失去大单</value><value>
</value><value>解决方案：设置两个判断标准，只有总量大而且发送次数多的发送方会被当做黑客</value><value>
</value><value>
</value><value>
</value><value>
</value><value>问题二</value><value>
</value><value>
</value><value>难以界定请求大小的合理范围，可能会因为定的上限导致问题，例如在总的统计数量很大的情况下（例如统计所有的历史记录），可能会使得所有用户的请求的大小都超过1500</value><value>
</value><value>解决方案：统计所有用户的请求总大小，计算正态分布曲线</value><value>
，将请求大小在P{|X-μ|&lt;2σ}=2Φ外的发送方列为黑客</value><value>
</value><value>
</value><value>
</value><value>
</value><value>
</value><value>选做：实现你的方法</value><value>
之所以选择正态分布判断是因为，正态分布在判断一些小概率、不可能事件中更为科学有效。</value><value>
</value><value>改进代码地址</value><value>
修改代码时遇到的一些坑和教训：</value><value>
</value><value>
</value><value>
</value><value>变量要做比较的时候，应注意其类型是否相同</value><value>
</value><value>
</value><value>
</value><value>python中的乘方与开方应使用“</value><value>2”、“</value><value>0.5”实现</value><value>
</value><value>
</value><value>
</value><value>变量命名要有意义，避免杂乱，影响思考和修改</value><value>
修改过程中发现的问题：</value><value>
</value><value>
</value><value>
</value><value>1.发送次数的上限难以确定，可能是因为样本数量不够大所导致的。</value><value>
</value><value>
</value><value>
</value><value>2.正态分布的合理范围难以确定，之前认为应该是X&gt;(μ+2σ)是因为在百度百科上看到词条解释中有一句话：“由于“小概率事件”和假设检验的基本思想 “小概率事件”通常指发生的概率小于5%的事件，认为在一次试验中该事件是几乎不可能发生的。”，因为P{|X-μ|&lt;2σ}=2Φ内的概率接近95%，故认为应该为2σ。但在改进过程中发现并非如此，95%的范围过于宽泛，容易把一些非黑客发送方纳入其中。而且因为第一个问题的存在，发送次数难以起到辅助判断的效果，导致在试验的时候结果与预期不符。</value><value>
</value><value>
</value><value>

</value></text><lastUpdated>2019-01-31 23:22</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/archive/2019/02/17.html</url><title>2019 年 2月 17 日 随笔档案 - 氧化氟碳 - 博客园</title><text></text><lastUpdated>None</lastUpdated></item>
<item><url>https://www.cnblogs.com/holmze/default.html?page=1</url><title>氧化氟碳 - 博客园</title><text></text><lastUpdated>None</lastUpdated></item>
<item><url>http://feed.cnblogs.com/blog/u/490223/rss/</url><title>None</title><text></text><lastUpdated>None</lastUpdated></item>
</items>